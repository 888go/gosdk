
<原文开始>
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
<原文结束>

# <翻译开始>
//版权所有2009年Go作者。所有权利保留。
//使用此源代码受BSD风格
//可以在LICENSE文件中找到的许可证。
// md5:2e9dc81828a3be8a
# <翻译结束>


<原文开始>
// a struct field that Formats
<原文结束>

# <翻译开始>
// 一个格式化的结构体字段. md5:52bfc44b0cbc23de
# <翻译结束>


<原文开始>
// a struct field that GoStrings
<原文结束>

# <翻译开始>
// 一个被GoStrings处理的结构体字段. md5:678004271a9aa89a
# <翻译结束>


<原文开始>
// P is a type with a String method with pointer receiver for testing %p.
<原文结束>

# <翻译开始>
// P是一个类型，它有一个指向接收者为指针的String方法，用于测试%p。. md5:9b954d1a9346882d
# <翻译结束>


<原文开始>
// The space modifier should have no effect.
<原文结束>

# <翻译开始>
// 空间修饰符应该没有影响。. md5:bbfde4ac476f29bc
# <翻译结束>


<原文开始>
// 0 has no effect when - is present.
<原文结束>

# <翻译开始>
// 0 在有 - 存在时没有效果。. md5:f3591d20cebe5085
# <翻译结束>


<原文开始>
// Runes that are not printable.
<原文结束>

# <翻译开始>
// 不是可打印的 runes。. md5:8971fe79b962e715
# <翻译结束>


<原文开始>
// Runes that are not valid.
<原文结束>

# <翻译开始>
// 不是有效 runes。. md5:331c0d0ba13a40c3
# <翻译结束>


<原文开始>
// Specifying precision should have no effect.
<原文结束>

# <翻译开始>
// 指定精度应该没有影响。. md5:c31539d424885085
# <翻译结束>


<原文开始>
// Test correct f.intbuf overflow checks.
<原文结束>

# <翻译开始>
// 测试正确的f.intbuf溢出检查。. md5:eb107ec8cd656965
# <翻译结束>


<原文开始>
// Plus flag should have no effect.
<原文结束>

# <翻译开始>
// Plus标志应该没有效果。. md5:97bfd84283b2e17a
# <翻译结束>


<原文开始>
// Space flag should have no effect.
<原文结束>

# <翻译开始>
// 空格标志应该没有影响。. md5:d91ceeb036bce5c8
# <翻译结束>


<原文开始>
// Precisions below 4 should print 4 digits.
<原文结束>

# <翻译开始>
// 低于4的精度应打印4位数字。. md5:94c83203083269c5
# <翻译结束>


<原文开始>
// Test sharp flag used with floats.
<原文结束>

# <翻译开始>
// 测试浮点数中使用的sharp标志。. md5:c7ce62d50d03fd2a
# <翻译结束>


<原文开始>
// The sharp flag has no effect for binary float format.
<原文结束>

# <翻译开始>
// 尖峰标志对二进制浮点格式没有影响。. md5:529fed249f6eea8f
# <翻译结束>


<原文开始>
// Precision has no effect for binary float format.
<原文结束>

# <翻译开始>
// 精度对二进制浮点格式没有影响。. md5:393e6f53d4dd83a9
# <翻译结束>


<原文开始>
// Test correct f.intbuf boundary checks.
<原文结束>

# <翻译开始>
// 测试f.intbuf边界检查的正确性。. md5:163a76ec1df687fe
# <翻译结束>


<原文开始>
// float infinites and NaNs
<原文结束>

# <翻译开始>
// 浮点数的无穷大和NaN（非数字）. md5:19bfeced45fe6478
# <翻译结束>


<原文开始>
// Zero padding does not apply to infinities and NaN.
<原文结束>

# <翻译开始>
// 零填充不适用于无穷大和NaN。. md5:0f35f381c57ccf6e
# <翻译结束>


<原文开始>
// The sharp flag has no effect for binary complex format.
<原文结束>

# <翻译开始>
// 尖峰标志对二进制复数格式没有影响。. md5:5a17eaa8bd9da0ab
# <翻译结束>


<原文开始>
// Precision has no effect for binary complex format.
<原文结束>

# <翻译开始>
// 精度对二进制复数格式没有影响。. md5:7428a8f9950bcd16
# <翻译结束>


<原文开始>
// complex infinites and NaNs
<原文结束>

# <翻译开始>
// 复数无穷大和NaNs. md5:e32d7333c8cfdb51
# <翻译结束>


<原文开始>
// byte arrays and slices with %b,%c,%d,%o,%U and %v
<原文结束>

# <翻译开始>
// 与 %b, %c, %d, %o, %U 和 %v 关联的字节数组和切片. md5:c16fef7931ed6c04
# <翻译结束>


<原文开始>
// f.space should and f.plus should not have an effect with %v.
<原文结束>

# <翻译开始>
// f.space和f.plus应该对%v没有影响。. md5:068db9ba1113b797
# <翻译结束>


<原文开始>
// f.space and f.plus should have an effect with %d.
<原文结束>

# <翻译开始>
// f.space 和 f.plus 应当对 %d 起作用。. md5:1a75e496c2703ffa
# <翻译结束>


<原文开始>
// +v on structs with Stringable items
<原文结束>

# <翻译开始>
// +v 在包含可打印项的结构体上. md5:4abb2b10afc9883c
# <翻译结束>


<原文开始>
// other formats on Stringable items
<原文结束>

# <翻译开始>
// 对Stringable类型的其他格式. md5:804ca88a9d116b3a
# <翻译结束>


<原文开始>
// Stringer applies only to string formats.
<原文结束>

# <翻译开始>
// Stringer 仅适用于字符串格式。. md5:166e200c8e9b04dd
# <翻译结束>


<原文开始>
// Stringer applies to the extracted value.
<原文结束>

# <翻译开始>
// Stringer 应用于提取的值。. md5:2bfa36aabd9035aa
# <翻译结束>


<原文开始>
// Whole number floats are printed without decimals. See Issue 27634.
<原文结束>

# <翻译开始>
// 完全数浮点数以整数形式打印，不带小数部分。参见问题27634。. md5:3d24e1b73d5a4878
# <翻译结束>


<原文开始>
// Only print []byte and []uint8 as type []byte if they appear at the top level.
<原文结束>

# <翻译开始>
// 只有在顶级出现[]byte和[]uint8时，才将它们作为类型[]byte进行打印。. md5:6a66f14eeec9f3b5
# <翻译结束>


<原文开始>
// slices with other formats
<原文结束>

# <翻译开始>
// 其他格式的切片. md5:596a58ca6b628cb1
# <翻译结束>


<原文开始>
// Padding with byte slices.
<原文结束>

# <翻译开始>
// 使用字节切片进行填充。. md5:87d6a838449d19c8
# <翻译结束>


<原文开始>
// nil on its own has no type ...
<原文结束>

# <翻译开始>
// nil本身没有类型.... md5:e8974e42e6290323
# <翻译结束>


<原文开始>
// ... and hence is not a pointer type.
<原文结束>

# <翻译开始>
// 因此它不是一个指针类型。. md5:0cfabb45fd59930e
# <翻译结束>


<原文开始>
// pointers with specified base
<原文结束>

# <翻译开始>
// 指针与特定基址. md5:9de4be58346b82c0
# <翻译结束>


<原文开始>
// string method on pointer
<原文结束>

# <翻译开始>
// 指针上的字符串方法. md5:8c023bfe28cba065
# <翻译结束>


<原文开始>
// ... is not called with %p.
<原文结束>

# <翻译开始>
// ... 不会使用 %p 调用。. md5:4318cf71cb5622c3
# <翻译结束>


<原文开始>
// %d on Stringer should give integer if possible
<原文结束>

# <翻译开始>
// 如果Stringer可以，%d应该给出整数. md5:9771b0ed2261119a
# <翻译结束>


<原文开始>
// Extra argument errors should format without flags set.
<原文结束>

# <翻译开始>
// 额外参数错误应该在不设置标志的情况下进行格式化。. md5:6c1f678ff096a565
# <翻译结束>


<原文开始>
// Test that maps with non-reflexive keys print all keys and values.
<原文结束>

# <翻译开始>
// 测试非自反键的映射能否打印所有键和值。. md5:dd521c24773421c2
# <翻译结束>


<原文开始>
// Comparison of padding rules with C printf.
<原文结束>

# <翻译开始>
// 与C语言的printf函数格式化填充规则进行比较。. md5:862bcbe6e5fedea8
# <翻译结束>


<原文开始>
// Complex numbers: exhaustively tested in TestComplexFormatting.
<原文结束>

# <翻译开始>
// 复数：在TestComplexFormatting中进行了详尽的测试。. md5:664caeb88491f1cd
# <翻译结束>


<原文开始>
// Use spaces instead of zero if padding to the right.
<原文结束>

# <翻译开始>
// 如果需要向右填充，请使用空格代替0。. md5:1be62c0543bb9239
# <翻译结束>


<原文开始>
	// float and complex formatting should not change the padding width
	// for other elements. See issue 14642.
<原文结束>

# <翻译开始>
	// 浮点数和复数的格式化不应改变其他元素的填充宽度。参见问题 14642。
	// md5:439398b6d06f2102
# <翻译结束>


<原文开始>
// integer formatting should not alter padding for other elements.
<原文结束>

# <翻译开始>
// 整数格式化不应该改变其他元素的填充。. md5:350ce4fb57cac29b
# <翻译结束>


<原文开始>
	// Complex fmt used to leave the plus flag set for future entries in the array
	// causing +2+0i and +3+0i instead of 2+0i and 3+0i.
<原文结束>

# <翻译开始>
	// 使用复杂的格式化选项，以便在数组的后续条目中保留加号标志，这样会显示为 +2+0i 和 +3+0i 而不是 2+0i 和 3+0i。
	// md5:5556f06edd7c4b3d
# <翻译结束>


<原文开始>
// Incomplete format specification caused crash.
<原文结束>

# <翻译开始>
// 不完整的格式说明导致了崩溃。. md5:e416c8bd61ffefa1
# <翻译结束>


<原文开始>
// Padding for complex numbers. Has been bad, then fixed, then bad again.
<原文结束>

# <翻译开始>
// 复数的填充。曾存在问题，然后被修复，但随后又出现了问题。. md5:d10742a3da07ff00
# <翻译结束>


<原文开始>
// []T where type T is a byte with a Stringer method.
<原文结束>

# <翻译开始>
// []T，其中类型T是一个具有Stringer方法的字节。. md5:b82654802b5d90a1
# <翻译结束>


<原文开始>
// And the same for Formatter.
<原文结束>

# <翻译开始>
// 对Formatter也是如此。. md5:3d5d2c393e654574
# <翻译结束>


<原文开始>
// This next case seems wrong, but the docs say the Formatter wins here.
<原文结束>

# <翻译开始>
// 下一个情况看起来是错误的，但文档说明Formatter在这里会取胜。. md5:fcc2426006db2b69
# <翻译结束>


<原文开始>
	// reflect.Value handled specially in Go 1.5, making it possible to
	// see inside non-exported fields (which cannot be accessed with Interface()).
	// Issue 8965.
<原文结束>

# <翻译开始>
	// 在Go 1.5中特别处理了reflect.Value，使得可以
	// 观察非导出字段的内部（这些字段无法通过Interface()访问）。
	// 问题Issue 8965。
	// md5:f53b74d57ef9e0e9
# <翻译结束>


<原文开始>
// Equivalent to the old way.
<原文结束>

# <翻译开始>
// 等同于旧的方法。. md5:b288249e76f1a71f
# <翻译结束>


<原文开始>
// verbs apply to the extracted value too.
<原文结束>

# <翻译开始>
// 这些动词也作用于提取的值。. md5:591df534d9964828
# <翻译结束>


<原文开始>
// invalid reflect.Value doesn't crash.
<原文结束>

# <翻译开始>
// 无效的反射.Value不会导致崩溃。. md5:47b7e95a4a28f4ce
# <翻译结束>


<原文开始>
// Tests to check that not supported verbs generate an error string.
<原文结束>

# <翻译开始>
// 测试检查不支持的动词是否会生成错误信息。. md5:3fd253b1e4347a90
# <翻译结束>


<原文开始>
// zeroFill generates zero-filled strings of the specified width. The length
// of the suffix (but not the prefix) is compensated for in the width calculation.
<原文结束>

# <翻译开始>
// zeroFill 生成指定宽度的零填充字符串。在计算宽度时会补偿后缀（而不是前缀）的长度。
// md5:166c1bba0c8b0fa3
# <翻译结束>


<原文开始>
				// Don't requote the already-quoted strings.
				// It's too confusing to read the errors.
<原文结束>

# <翻译开始>
				// 不要对已经引用的字符串进行二次引用。
				// 阅读错误信息会很困惑。
				// md5:ba8c726918db0e02
# <翻译结束>


<原文开始>
// TestComplexFormatting checks that a complex always formats to the same
// thing as if done by hand with two singleton prints.
<原文结束>

# <翻译开始>
// TestComplexFormatting 检查一个复杂的格式化结果是否始终与手动使用两个单例打印得到的结果相同。
// md5:d4dd5d418eb8bbcb
# <翻译结束>


<原文开始>
// Imaginary part always has a sign, so force + and ignore space.
<原文结束>

# <翻译开始>
// 虚部总是有符号的，因此强制使用+并忽略空格。. md5:3478885701ff07cb
# <翻译结束>


<原文开始>
// slice of empty; notational compactness.
<原文结束>

# <翻译开始>
// 空的切片；表示上的紧凑性。. md5:0c6510b82e66fcbc
# <翻译结束>


<原文开始>
// Explicit version of next line.
<原文结束>

# <翻译开始>
// 下一行的显式版本。. md5:6ac52b71311e0e5f
# <翻译结束>


<原文开始>
// Explicit version of next line; empty precision means zero.
<原文结束>

# <翻译开始>
// 下一行的明确版本；空精度意味着零。. md5:beec2c5c5bdb243b
# <翻译结束>


<原文开始>
// An actual use! Print the same arguments twice.
<原文结束>

# <翻译开始>
// 一个实际的应用！打印两次相同的参数。. md5:50c392eca0f17937
# <翻译结束>


<原文开始>
// Erroneous index does not affect sequence.
<原文结束>

# <翻译开始>
// 错误的索引不会影响序列。. md5:2a002c80f25a97e9
# <翻译结束>


<原文开始>
// TODO: Should this set return better error messages?
<原文结束>

# <翻译开始>
// TODO：这个设置应该返回更好的错误消息吗？. md5:83eec8be12b4cb4b
# <翻译结束>


<原文开始>
// If the interface value doesn't need to allocate, amortized allocation overhead should be zero.
<原文结束>

# <翻译开始>
// 如果接口值不需要分配，那么折旧分配开销应该是零。. md5:3b4c5ae37bedf5d7
# <翻译结束>


<原文开始>
// The same but with a pointer.
<原文结束>

# <翻译开始>
// 同样是这个，但是使用了指针。. md5:b52f4a5b228ff7de
# <翻译结束>


<原文开始>
// presentInMap checks map printing using substrings so we don't depend on the
// print order.
<原文结束>

# <翻译开始>
// presentInMap 检查映射中是否存在指定的子字符串，这样我们就不依赖于打印顺序。
// md5:793ea6a69c121ef4
# <翻译结束>


<原文开始>
// make sure the match ends here
<原文结束>

# <翻译开始>
// 确保匹配在这里结束. md5:51f55c798e9f7848
# <翻译结束>


<原文开始>
// Pointer to map prints the same but with initial &.
<原文结束>

# <翻译开始>
// 地址符指向的映射打印相同，但带有初始的&。. md5:fe7b293d22d96ece
# <翻译结束>


<原文开始>
// TestBlank checks that Sprint (and hence Print, Fprint) puts spaces in the
// right places, that is, between arg pairs in which neither is a string.
<原文结束>

# <翻译开始>
// TestBlank 检查 Sprint（以及因此 Print、Fprint）是否在正确的位置插入空格，
// 也就是说，在两个都不是字符串的参数对之间插入空格。
// md5:53c45912a74541c9
# <翻译结束>


<原文开始>
// TestBlankln checks that Sprintln (and hence Println, Fprintln) puts spaces in
// the right places, that is, between all arg pairs.
<原文结束>

# <翻译开始>
// TestBlankln 检查 Sprintln（因此也检查 Println 和 Fprintln）是否在正确的位置放置空格，即在所有参数对之间。
// md5:808febd555ac992a
# <翻译结束>


<原文开始>
// TestFormatterPrintln checks Formatter with Sprint, Sprintln, Sprintf.
<原文结束>

# <翻译开始>
// TestFormatterPrintln 检查 Formatter 是否与 Sprint、Sprintln、Sprintf 兼容。. md5:317c04475c2e31e1
# <翻译结束>


<原文开始>
// Some non-int types for width. (Issue 10732).
<原文结束>

# <翻译开始>
// 一些非整型的宽度。 (问题 10732)。. md5:c7b71c0c4570660b
# <翻译结束>


<原文开始>
// PanicS is a type that panics in String.
<原文结束>

# <翻译开始>
// PanicS 是一个类型，其在 String 方法中引发恐慌。. md5:f9f51e76f8663022
# <翻译结束>


<原文开始>
// PanicGo is a type that panics in GoString.
<原文结束>

# <翻译开始>
// PanicGo 是一种类型，其在 GoString 方法中会引发 panic。. md5:325e8a82677affa7
# <翻译结束>


<原文开始>
// PanicF is a type that panics in Format.
<原文结束>

# <翻译开始>
// PanicF 是一个在 Format 中引发 panic 的类型。. md5:75281a7f645c4884
# <翻译结束>


<原文开始>
// nil pointer special case
<原文结束>

# <翻译开始>
// 对空指针的特殊处理. md5:3aa8c1e6fd615479
# <翻译结束>


<原文开始>
// Issue 18282. catchPanic should not clear fmtFlags permanently.
<原文结束>

# <翻译开始>
// Issue 18282。catchPanic 不应该永久性地清除 fmtFlags。. md5:58923a2a12714a31
# <翻译结束>


<原文开始>
// recurCount tests that erroneous String routine doesn't cause fatal recursion.
<原文结束>

# <翻译开始>
// recurCount 测试错误的 String 函数不会导致致命递归。. md5:0f835493bc816db5
# <翻译结束>


<原文开始>
	// This will call badVerb. Before the fix, that would cause us to recur into
	// this routine to print %!p(value). Now we don't call the user's method
	// during an error.
<原文结束>

# <翻译开始>
	// 这将调用badVerb。在修复之前，这会导致我们递归进入此例程来打印%!p(value)。现在，我们在发生错误时不会调用用户的函数。
	// md5:9a0c04ff32b63d48
# <翻译结束>


<原文开始>
	// This tests the internal isSpace function.
	// IsSpace = isSpace is defined in export_test.go.
<原文结束>

# <翻译开始>
	// 这个测试了内部的isSpace函数。
	// isSpace 是在 export_test.go 中定义的。
	// md5:6f01a8f9bb93e8c0
# <翻译结束>


<原文开始>
// scalar values with the (unused by fmt) 'a' verb.
<原文结束>

# <翻译开始>
// 使用（被fmt包未使用的）'a' 修饰符的标量值。. md5:fb9ef85626d44528
# <翻译结束>


<原文开始>
// composite values with the 'a' verb
<原文结束>

# <翻译开始>
// 使用 'a' 动词组合值. md5:53eb4e452bf8ac9e
# <翻译结束>


<原文开始>
// simple values with the 'v' verb
<原文结束>

# <翻译开始>
// 使用'v'动词的简单值. md5:55fa2b55a52125f3
# <翻译结束>


<原文开始>
// composite values with the 'v' verb.
<原文结束>

# <翻译开始>
// 使用'v'动词组合值。. md5:5c3ded605cfc3db8
# <翻译结束>


<原文开始>
// Test the various Append printers. The details are well tested above;
// here we just make sure the byte slice is updated.
<原文结束>

# <翻译开始>
// 测试各种追加打印机。详细的测试在上面已经充分进行；
// 这里我们主要确保字节切片能正确更新。
// md5:00bb4b00e53a3982
# <翻译结束>

