
<原文开始>
// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
<原文结束>

# <翻译开始>
// 版权所有 ? 2022 Go作者。保留所有权利。
// 本源代码的使用受 BSD 风格许可证约束，
// 该许可证可在 LICENSE 文件中找到。
# <翻译结束>


<原文开始>
// CoverPkgConfig is a bundle of information passed from the Go
// command to the cover command during "go build -cover" runs. The
// Go command creates and fills in a struct as below, then passes
// file containing the encoded JSON for the struct to the "cover"
// tool when instrumenting the source files in a Go package.
<原文结束>

# <翻译开始>
// CoverPkgConfig 是一组在执行“go build -cover”时从 Go 命令传递给 cover 命令的信息。Go 命令创建并填充如下的结构体，然后在对 Go 包中的源文件进行插桩时，将包含该结构体编码后的 JSON 数据的文件传递给“cover”工具。
# <翻译结束>


<原文开始>
	// File into which cmd/cover should emit summary info
	// when instrumentation is complete.
<原文结束>

# <翻译开始>
// 当代码覆盖率工具完成插桩后，应向该文件输出总结信息。
// 
// 注释含义：在Go语言中，当命令行工具`cmd/cover`完成代码覆盖率的插桩（即统计代码覆盖率所需的信息注入）之后，应当将生成的覆盖率总结信息输出到指定的文件中。
# <翻译结束>


<原文开始>
// Import path for the package being instrumented.
<原文结束>

# <翻译开始>
// 正在进行instrument操作的包的导入路径。
# <翻译结束>


<原文开始>
// Instrumentation granularity: one of "perfunc" or "perblock" (default)
<原文结束>

# <翻译开始>
// 仪器化粒度： "perfunc" 或 "perblock"（默认）中的一个
# <翻译结束>


<原文开始>
// Module path for this package (empty if no go.mod in use)
<原文结束>

# <翻译开始>
// 此包的模块路径（如果未使用 go.mod，则为空）
# <翻译结束>


<原文开始>
	// Local mode indicates we're doing a coverage build or test of a
	// package selected via local import path, e.g. "./..." or
	// "./foo/bar" as opposed to a non-relative import path. See the
	// corresponding field in cmd/go's PackageInternal struct for more
	// info.
<原文结束>

# <翻译开始>
// 本地模式表示我们正在进行通过本地导入路径选择的包的覆盖率构建或测试，例如 "./..." 或 "./foo/bar"，而不是非相对导入路径。有关更多信息，请参阅 cmd/go 中对应的 PackageInternal 结构体字段。
# <翻译结束>


<原文开始>
// CoverFixupConfig contains annotations/notes generated by the
// cmd/cover tool (during instrumentation) to be passed on to the
// compiler when the instrumented code is compiled. The cmd/cover tool
// creates a struct of this type, JSON-encodes it, and emits the
// result to a file, which the Go command then passes to the compiler
// when the instrumented package is built.
<原文结束>

# <翻译开始>
// CoverFixupConfig 包含由 `cmd/cover` 工具（在进行代码插桩时）生成的注释/备注，这些信息将在编译被插桩代码时传递给编译器。`cmd/cover` 工具会创建一个该类型的结构体实例，将其 JSON 编码后写入文件。Go 命令在构建被插桩包时，会将此文件内容传递给编译器。
# <翻译结束>


<原文开始>
	// Name of the variable (created by cmd/cover) containing the
	// encoded meta-data for the package.
<原文结束>

# <翻译开始>
// Name变量（由cmd/cover创建）包含包的编码元数据。
# <翻译结束>


<原文开始>
// Length of the meta-data.
<原文结束>

# <翻译开始>
// 元数据的长度。
# <翻译结束>


<原文开始>
// Hash computed by cmd/cover of the meta-data.
<原文结束>

# <翻译开始>
// 由cmd/cover计算出的元数据哈希值。
# <翻译结束>


<原文开始>
	// Instrumentation strategy. For now this is always set to
	// "normal", but in the future we may add new values (for example,
	// if panic paths are instrumented, or if the instrumenter
	// eliminates redundant counters).
<原文结束>

# <翻译开始>
// 监测策略。目前该值始终设置为 "normal"，但未来我们可能会添加新的值（例如，如果对 panic 路径进行监测，或者监测器消除了重复的计数器时）。
# <翻译结束>


<原文开始>
	// Prefix assigned to the names of counter variables generated
	// during instrumentation by cmd/cover.
<原文结束>

# <翻译开始>
// 在cmd/cover进行代码检测时，为生成的计数器变量名称所赋予的前缀。
# <翻译结束>


<原文开始>
	// Name chosen for the package ID variable generated during
	// instrumentation.
<原文结束>

# <翻译开始>
// 为在进行instrumentation时生成的包ID变量选择的名称。
# <翻译结束>


<原文开始>
// Counter mode (e.g. set/count/atomic)
<原文结束>

# <翻译开始>
// 计数器模式（例如：设置/计数/原子操作）
# <翻译结束>


<原文开始>
// Counter granularity (perblock or perfunc).
<原文结束>

# <翻译开始>
// 计数器的粒度（按块或按函数）。
# <翻译结束>

