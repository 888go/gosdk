//ç‰ˆæƒæ‰€æœ‰2009å¹´Goä½œè€…ã€‚æ‰€æœ‰æƒåˆ©ä¿ç•™ã€‚
//ä½¿ç”¨æ­¤æºä»£ç å—BSDé£æ ¼
//å¯ä»¥åœ¨LICENSEæ–‡ä»¶ä¸­æ‰¾åˆ°çš„è®¸å¯è¯ã€‚
// md5:2e9dc81828a3be8a

package fmt_test

import (
	"bytes"
	fmt2 "fmt"
	. "github.com/888go/gosdk/fmt"
	"github.com/888go/gosdk/fmt/internal/race"
	"io"
	"math"
	"reflect"
	"runtime"
	"strings"
	"testing"
	"time"
)

type (
	renamedBool       bool
	renamedInt        int
	renamedInt8       int8
	renamedInt16      int16
	renamedInt32      int32
	renamedInt64      int64
	renamedUint       uint
	renamedUint8      uint8
	renamedUint16     uint16
	renamedUint32     uint32
	renamedUint64     uint64
	renamedUintptr    uintptr
	renamedString     string
	renamedBytes      []byte
	renamedFloat32    float32
	renamedFloat64    float64
	renamedComplex64  complex64
	renamedComplex128 complex128
)

func TestFmtInterface(t *testing.T) {
	var i1 any
	i1 = "abc"
	s := Sprintf("%s", i1)
	if s != "abc" {
		t.Errorf(`Sprintf("%%s", empty("abc")) = %q want %q`, s, "abc")
	}
}

var (
	NaN    = math.NaN()
	posInf = math.Inf(1)
	negInf = math.Inf(-1)

	intVar = 0

	array  = [5]int{1, 2, 3, 4, 5}
	iarray = [4]any{1, "hello", 2.5, nil}
	slice  = array[:]
	islice = iarray[:]
)

type A struct {
	i int
	j uint
	s string
	x []int
}

type I int

func (i I) String() string { return Sprintf("<%d>", int(i)) }

type B struct {
	I I
	j int
}

type C struct {
	i int
	B
}

type F int

func (f F) Format(s fmt2.State, c rune) {
	Fprintf(s, "<%c=F(%d)>", c, int(f))
}

type G int

func (g G) GoString() string {
	return Sprintf("GoString(%d)", int(g))
}

type S struct {
	F F // ä¸€ä¸ªæ ¼å¼åŒ–çš„ç»“æ„ä½“å­—æ®µ. md5:52bfc44b0cbc23de
	G G // ä¸€ä¸ªè¢«GoStringså¤„ç†çš„ç»“æ„ä½“å­—æ®µ. md5:678004271a9aa89a
}

type SI struct {
	I any
}

// Pæ˜¯ä¸€ä¸ªç±»å‹ï¼Œå®ƒæœ‰ä¸€ä¸ªæŒ‡å‘æ¥æ”¶è€…ä¸ºæŒ‡é’ˆçš„Stringæ–¹æ³•ï¼Œç”¨äºæµ‹è¯•%pã€‚. md5:9b954d1a9346882d
type P int

var pValue P

func (p *P) String() string {
	return "String(p)"
}

var barray = [5]renamedUint8{1, 2, 3, 4, 5}
var bslice = barray[:]

type byteStringer byte

func (byteStringer) String() string {
	return "X"
}

var byteStringerSlice = []byteStringer{'h', 'e', 'l', 'l', 'o'}

type byteFormatter byte

func (byteFormatter) Format(f fmt2.State, _ rune) {
	Fprint(f, "X")
}

var byteFormatterSlice = []byteFormatter{'h', 'e', 'l', 'l', 'o'}

type writeStringFormatter string

func (sf writeStringFormatter) Format(f fmt2.State, c rune) {
	if sw, ok := f.(io.StringWriter); ok {
		sw.WriteString("***" + string(sf) + "***")
	}
}

var fmtTests = []struct {
	fmt string
	val any
	out string
}{
	{"%d", 12345, "12345"},
	{"%v", 12345, "12345"},
	{"%t", true, "true"},

	// basic string
	{"%s", "abc", "abc"},
	{"%q", "abc", `"abc"`},
	{"%x", "abc", "616263"},
	{"%x", "\xff\xf0\x0f\xff", "fff00fff"},
	{"%X", "\xff\xf0\x0f\xff", "FFF00FFF"},
	{"%x", "", ""},
	{"% x", "", ""},
	{"%#x", "", ""},
	{"%# x", "", ""},
	{"%x", "xyz", "78797a"},
	{"%X", "xyz", "78797A"},
	{"% x", "xyz", "78 79 7a"},
	{"% X", "xyz", "78 79 7A"},
	{"%#x", "xyz", "0x78797a"},
	{"%#X", "xyz", "0X78797A"},
	{"%# x", "xyz", "0x78 0x79 0x7a"},
	{"%# X", "xyz", "0X78 0X79 0X7A"},

	// basic bytes
	{"%s", []byte("abc"), "abc"},
	{"%s", [3]byte{'a', 'b', 'c'}, "abc"},
	{"%s", &[3]byte{'a', 'b', 'c'}, "&abc"},
	{"%q", []byte("abc"), `"abc"`},
	{"%x", []byte("abc"), "616263"},
	{"%x", []byte("\xff\xf0\x0f\xff"), "fff00fff"},
	{"%X", []byte("\xff\xf0\x0f\xff"), "FFF00FFF"},
	{"%x", []byte(""), ""},
	{"% x", []byte(""), ""},
	{"%#x", []byte(""), ""},
	{"%# x", []byte(""), ""},
	{"%x", []byte("xyz"), "78797a"},
	{"%X", []byte("xyz"), "78797A"},
	{"% x", []byte("xyz"), "78 79 7a"},
	{"% X", []byte("xyz"), "78 79 7A"},
	{"%#x", []byte("xyz"), "0x78797a"},
	{"%#X", []byte("xyz"), "0X78797A"},
	{"%# x", []byte("xyz"), "0x78 0x79 0x7a"},
	{"%# X", []byte("xyz"), "0X78 0X79 0X7A"},

	// escaped strings
	{"%q", "", `""`},
	{"%#q", "", "``"},
	{"%q", "\"", `"\""`},
	{"%#q", "\"", "`\"`"},
	{"%q", "`", `"` + "`" + `"`},
	{"%#q", "`", `"` + "`" + `"`},
	{"%q", "\n", `"\n"`},
	{"%#q", "\n", `"\n"`},
	{"%q", `\n`, `"\\n"`},
	{"%#q", `\n`, "`\\n`"},
	{"%q", "abc", `"abc"`},
	{"%#q", "abc", "`abc`"},
	{"%q", "æ—¥æœ¬èª", `"æ—¥æœ¬èª"`},
	{"%+q", "æ—¥æœ¬èª", `"\u65e5\u672c\u8a9e"`},
	{"%#q", "æ—¥æœ¬èª", "`æ—¥æœ¬èª`"},
	{"%#+q", "æ—¥æœ¬èª", "`æ—¥æœ¬èª`"},
	{"%q", "\a\b\f\n\r\t\v\"\\", `"\a\b\f\n\r\t\v\"\\"`},
	{"%+q", "\a\b\f\n\r\t\v\"\\", `"\a\b\f\n\r\t\v\"\\"`},
	{"%#q", "\a\b\f\n\r\t\v\"\\", `"\a\b\f\n\r\t\v\"\\"`},
	{"%#+q", "\a\b\f\n\r\t\v\"\\", `"\a\b\f\n\r\t\v\"\\"`},
	{"%q", "â˜º", `"â˜º"`},
	{"% q", "â˜º", `"â˜º"`}, // ç©ºé—´ä¿®é¥°ç¬¦åº”è¯¥æ²¡æœ‰å½±å“ã€‚. md5:bbfde4ac476f29bc
	{"%+q", "â˜º", `"\u263a"`},
	{"%#q", "â˜º", "`â˜º`"},
	{"%#+q", "â˜º", "`â˜º`"},
	{"%10q", "âŒ˜", `       "âŒ˜"`},
	{"%+10q", "âŒ˜", `  "\u2318"`},
	{"%-10q", "âŒ˜", `"âŒ˜"       `},
	{"%+-10q", "âŒ˜", `"\u2318"  `},
	{"%010q", "âŒ˜", `0000000"âŒ˜"`},
	{"%+010q", "âŒ˜", `00"\u2318"`},
	{"%-010q", "âŒ˜", `"âŒ˜"       `}, // 0 åœ¨æœ‰ - å­˜åœ¨æ—¶æ²¡æœ‰æ•ˆæœã€‚. md5:f3591d20cebe5085
	{"%+-010q", "âŒ˜", `"\u2318"  `},
	{"%#8q", "\n", `    "\n"`},
	{"%#+8q", "\r", `    "\r"`},
	{"%#-8q", "\t", "`	`     "},
	{"%#+-8q", "\b", `"\b"    `},
	{"%q", "abc\xffdef", `"abc\xffdef"`},
	{"%+q", "abc\xffdef", `"abc\xffdef"`},
	{"%#q", "abc\xffdef", `"abc\xffdef"`},
	{"%#+q", "abc\xffdef", `"abc\xffdef"`},
	// ä¸æ˜¯å¯æ‰“å°çš„ runesã€‚. md5:8971fe79b962e715
	{"%q", "\U0010ffff", `"\U0010ffff"`},
	{"%+q", "\U0010ffff", `"\U0010ffff"`},
	{"%#q", "\U0010ffff", "`ô¿¿`"},
	{"%#+q", "\U0010ffff", "`ô¿¿`"},
	// ä¸æ˜¯æœ‰æ•ˆ runesã€‚. md5:331c0d0ba13a40c3
	{"%q", string(rune(0x110000)), `"ï¿½"`},
	{"%+q", string(rune(0x110000)), `"\ufffd"`},
	{"%#q", string(rune(0x110000)), "`ï¿½`"},
	{"%#+q", string(rune(0x110000)), "`ï¿½`"},

	// characters
	{"%c", uint('x'), "x"},
	{"%c", 0xe4, "Ã¤"},
	{"%c", 0x672c, "æœ¬"},
	{"%c", 'æ—¥', "æ—¥"},
	{"%.0c", 'âŒ˜', "âŒ˜"}, // æŒ‡å®šç²¾åº¦åº”è¯¥æ²¡æœ‰å½±å“ã€‚. md5:c31539d424885085
	{"%3c", 'âŒ˜', "  âŒ˜"},
	{"%-3c", 'âŒ˜', "âŒ˜  "},
	{"%c", uint64(0x100000000), "\ufffd"},
	// ä¸æ˜¯å¯æ‰“å°çš„ runesã€‚. md5:8971fe79b962e715
	{"%c", '\U00000e00', "\u0e00"},
	{"%c", '\U0010ffff', "\U0010ffff"},
	// ä¸æ˜¯æœ‰æ•ˆ runesã€‚. md5:331c0d0ba13a40c3
	{"%c", -1, "ï¿½"},
	{"%c", 0xDC80, "ï¿½"},
	{"%c", rune(0x110000), "ï¿½"},
	{"%c", int64(0xFFFFFFFFF), "ï¿½"},
	{"%c", uint64(0xFFFFFFFFF), "ï¿½"},

	// escaped characters
	{"%q", uint(0), `'\x00'`},
	{"%+q", uint(0), `'\x00'`},
	{"%q", '"', `'"'`},
	{"%+q", '"', `'"'`},
	{"%q", '\'', `'\''`},
	{"%+q", '\'', `'\''`},
	{"%q", '`', "'`'"},
	{"%+q", '`', "'`'"},
	{"%q", 'x', `'x'`},
	{"%+q", 'x', `'x'`},
	{"%q", 'Ã¿', `'Ã¿'`},
	{"%+q", 'Ã¿', `'\u00ff'`},
	{"%q", '\n', `'\n'`},
	{"%+q", '\n', `'\n'`},
	{"%q", 'â˜º', `'â˜º'`},
	{"%+q", 'â˜º', `'\u263a'`},
	{"% q", 'â˜º', `'â˜º'`},  // ç©ºé—´ä¿®é¥°ç¬¦åº”è¯¥æ²¡æœ‰å½±å“ã€‚. md5:bbfde4ac476f29bc
	{"%.0q", 'â˜º', `'â˜º'`}, // æŒ‡å®šç²¾åº¦åº”è¯¥æ²¡æœ‰å½±å“ã€‚. md5:c31539d424885085
	{"%10q", 'âŒ˜', `       'âŒ˜'`},
	{"%+10q", 'âŒ˜', `  '\u2318'`},
	{"%-10q", 'âŒ˜', `'âŒ˜'       `},
	{"%+-10q", 'âŒ˜', `'\u2318'  `},
	{"%010q", 'âŒ˜', `0000000'âŒ˜'`},
	{"%+010q", 'âŒ˜', `00'\u2318'`},
	{"%-010q", 'âŒ˜', `'âŒ˜'       `}, // 0 åœ¨æœ‰ - å­˜åœ¨æ—¶æ²¡æœ‰æ•ˆæœã€‚. md5:f3591d20cebe5085
	{"%+-010q", 'âŒ˜', `'\u2318'  `},
	// ä¸æ˜¯å¯æ‰“å°çš„ runesã€‚. md5:8971fe79b962e715
	{"%q", '\U00000e00', `'\u0e00'`},
	{"%q", '\U0010ffff', `'\U0010ffff'`},
	// ä¸æ˜¯æœ‰æ•ˆ runesã€‚. md5:331c0d0ba13a40c3
	{"%q", int32(-1), `'ï¿½'`},
	{"%q", 0xDC80, `'ï¿½'`},
	{"%q", rune(0x110000), `'ï¿½'`},
	{"%q", int64(0xFFFFFFFFF), `'ï¿½'`},
	{"%q", uint64(0xFFFFFFFFF), `'ï¿½'`},

	// width
	{"%5s", "abc", "  abc"},
	{"%5s", []byte("abc"), "  abc"},
	{"%2s", "\u263a", " â˜º"},
	{"%2s", []byte("\u263a"), " â˜º"},
	{"%-5s", "abc", "abc  "},
	{"%-5s", []byte("abc"), "abc  "},
	{"%05s", "abc", "00abc"},
	{"%05s", []byte("abc"), "00abc"},
	{"%5s", "abcdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz"},
	{"%5s", []byte("abcdefghijklmnopqrstuvwxyz"), "abcdefghijklmnopqrstuvwxyz"},
	{"%.5s", "abcdefghijklmnopqrstuvwxyz", "abcde"},
	{"%.5s", []byte("abcdefghijklmnopqrstuvwxyz"), "abcde"},
	{"%.0s", "æ—¥æœ¬èªæ—¥æœ¬èª", ""},
	{"%.0s", []byte("æ—¥æœ¬èªæ—¥æœ¬èª"), ""},
	{"%.5s", "æ—¥æœ¬èªæ—¥æœ¬èª", "æ—¥æœ¬èªæ—¥æœ¬"},
	{"%.5s", []byte("æ—¥æœ¬èªæ—¥æœ¬èª"), "æ—¥æœ¬èªæ—¥æœ¬"},
	{"%.10s", "æ—¥æœ¬èªæ—¥æœ¬èª", "æ—¥æœ¬èªæ—¥æœ¬èª"},
	{"%.10s", []byte("æ—¥æœ¬èªæ—¥æœ¬èª"), "æ—¥æœ¬èªæ—¥æœ¬èª"},
	{"%08q", "abc", `000"abc"`},
	{"%08q", []byte("abc"), `000"abc"`},
	{"%-8q", "abc", `"abc"   `},
	{"%-8q", []byte("abc"), `"abc"   `},
	{"%.5q", "abcdefghijklmnopqrstuvwxyz", `"abcde"`},
	{"%.5q", []byte("abcdefghijklmnopqrstuvwxyz"), `"abcde"`},
	{"%.5x", "abcdefghijklmnopqrstuvwxyz", "6162636465"},
	{"%.5x", []byte("abcdefghijklmnopqrstuvwxyz"), "6162636465"},
	{"%.3q", "æ—¥æœ¬èªæ—¥æœ¬èª", `"æ—¥æœ¬èª"`},
	{"%.3q", []byte("æ—¥æœ¬èªæ—¥æœ¬èª"), `"æ—¥æœ¬èª"`},
	{"%.1q", "æ—¥æœ¬èª", `"æ—¥"`},
	{"%.1q", []byte("æ—¥æœ¬èª"), `"æ—¥"`},
	{"%.1x", "æ—¥æœ¬èª", "e6"},
	{"%.1X", []byte("æ—¥æœ¬èª"), "E6"},
	{"%10.1q", "æ—¥æœ¬èªæ—¥æœ¬èª", `       "æ—¥"`},
	{"%10.1q", []byte("æ—¥æœ¬èªæ—¥æœ¬èª"), `       "æ—¥"`},
	{"%10v", nil, "     <nil>"},
	{"%-10v", nil, "<nil>     "},

	// integers
	{"%d", uint(12345), "12345"},
	{"%d", int(-12345), "-12345"},
	{"%d", ^uint8(0), "255"},
	{"%d", ^uint16(0), "65535"},
	{"%d", ^uint32(0), "4294967295"},
	{"%d", ^uint64(0), "18446744073709551615"},
	{"%d", int8(-1 << 7), "-128"},
	{"%d", int16(-1 << 15), "-32768"},
	{"%d", int32(-1 << 31), "-2147483648"},
	{"%d", int64(-1 << 63), "-9223372036854775808"},
	{"%.d", 0, ""},
	{"%.0d", 0, ""},
	{"%6.0d", 0, "      "},
	{"%06.0d", 0, "      "},
	{"% d", 12345, " 12345"},
	{"%+d", 12345, "+12345"},
	{"%+d", -12345, "-12345"},
	{"%b", 7, "111"},
	{"%b", -6, "-110"},
	{"%#b", 7, "0b111"},
	{"%#b", -6, "-0b110"},
	{"%b", ^uint32(0), "11111111111111111111111111111111"},
	{"%b", ^uint64(0), "1111111111111111111111111111111111111111111111111111111111111111"},
	{"%b", int64(-1 << 63), zeroFill("-1", 63, "")},
	{"%o", 01234, "1234"},
	{"%o", -01234, "-1234"},
	{"%#o", 01234, "01234"},
	{"%#o", -01234, "-01234"},
	{"%O", 01234, "0o1234"},
	{"%O", -01234, "-0o1234"},
	{"%o", ^uint32(0), "37777777777"},
	{"%o", ^uint64(0), "1777777777777777777777"},
	{"%#X", 0, "0X0"},
	{"%x", 0x12abcdef, "12abcdef"},
	{"%X", 0x12abcdef, "12ABCDEF"},
	{"%x", ^uint32(0), "ffffffff"},
	{"%X", ^uint64(0), "FFFFFFFFFFFFFFFF"},
	{"%.20b", 7, "00000000000000000111"},
	{"%10d", 12345, "     12345"},
	{"%10d", -12345, "    -12345"},
	{"%+10d", 12345, "    +12345"},
	{"%010d", 12345, "0000012345"},
	{"%010d", -12345, "-000012345"},
	{"%20.8d", 1234, "            00001234"},
	{"%20.8d", -1234, "           -00001234"},
	{"%020.8d", 1234, "            00001234"},
	{"%020.8d", -1234, "           -00001234"},
	{"%-20.8d", 1234, "00001234            "},
	{"%-20.8d", -1234, "-00001234           "},
	{"%-#20.8x", 0x1234abc, "0x01234abc          "},
	{"%-#20.8X", 0x1234abc, "0X01234ABC          "},
	{"%-#20.8o", 01234, "00001234            "},

	// æµ‹è¯•æ­£ç¡®çš„f.intbufæº¢å‡ºæ£€æŸ¥ã€‚. md5:eb107ec8cd656965
	{"%068d", 1, zeroFill("", 68, "1")},
	{"%068d", -1, zeroFill("-", 67, "1")},
	{"%#.68x", 42, zeroFill("0x", 68, "2a")},
	{"%.68d", -42, zeroFill("-", 68, "42")},
	{"%+.68d", 42, zeroFill("+", 68, "42")},
	{"% .68d", 42, zeroFill(" ", 68, "42")},
	{"% +.68d", 42, zeroFill("+", 68, "42")},

	// unicode format
	{"%U", 0, "U+0000"},
	{"%U", -1, "U+FFFFFFFFFFFFFFFF"},
	{"%U", '\n', `U+000A`},
	{"%#U", '\n', `U+000A`},
	{"%+U", 'x', `U+0078`},       // Plusæ ‡å¿—åº”è¯¥æ²¡æœ‰æ•ˆæœã€‚. md5:97bfd84283b2e17a
	{"%# U", 'x', `U+0078 'x'`},  // ç©ºæ ¼æ ‡å¿—åº”è¯¥æ²¡æœ‰å½±å“ã€‚. md5:d91ceeb036bce5c8
	{"%#.2U", 'x', `U+0078 'x'`}, // ä½äº4çš„ç²¾åº¦åº”æ‰“å°4ä½æ•°å­—ã€‚. md5:94c83203083269c5
	{"%U", '\u263a', `U+263A`},
	{"%#U", '\u263a', `U+263A 'â˜º'`},
	{"%U", '\U0001D6C2', `U+1D6C2`},
	{"%#U", '\U0001D6C2', `U+1D6C2 'ğ›‚'`},
	{"%#14.6U", 'âŒ˜', "  U+002318 'âŒ˜'"},
	{"%#-14.6U", 'âŒ˜', "U+002318 'âŒ˜'  "},
	{"%#014.6U", 'âŒ˜', "  U+002318 'âŒ˜'"},
	{"%#-014.6U", 'âŒ˜', "U+002318 'âŒ˜'  "},
	{"%.68U", uint(42), zeroFill("U+", 68, "2A")},
	{"%#.68U", 'æ—¥', zeroFill("U+", 68, "65E5") + " 'æ—¥'"},

	// floats
	{"%+.3e", 0.0, "+0.000e+00"},
	{"%+.3e", 1.0, "+1.000e+00"},
	{"%+.3x", 0.0, "+0x0.000p+00"},
	{"%+.3x", 1.0, "+0x1.000p+00"},
	{"%+.3f", -1.0, "-1.000"},
	{"%+.3F", -1.0, "-1.000"},
	{"%+.3F", float32(-1.0), "-1.000"},
	{"%+07.2f", 1.0, "+001.00"},
	{"%+07.2f", -1.0, "-001.00"},
	{"%-07.2f", 1.0, "1.00   "},
	{"%-07.2f", -1.0, "-1.00  "},
	{"%+-07.2f", 1.0, "+1.00  "},
	{"%+-07.2f", -1.0, "-1.00  "},
	{"%-+07.2f", 1.0, "+1.00  "},
	{"%-+07.2f", -1.0, "-1.00  "},
	{"%+10.2f", +1.0, "     +1.00"},
	{"%+10.2f", -1.0, "     -1.00"},
	{"% .3E", -1.0, "-1.000E+00"},
	{"% .3e", 1.0, " 1.000e+00"},
	{"% .3X", -1.0, "-0X1.000P+00"},
	{"% .3x", 1.0, " 0x1.000p+00"},
	{"%+.3g", 0.0, "+0"},
	{"%+.3g", 1.0, "+1"},
	{"%+.3g", -1.0, "-1"},
	{"% .3g", -1.0, "-1"},
	{"% .3g", 1.0, " 1"},
	{"%b", float32(1.0), "8388608p-23"},
	{"%b", 1.0, "4503599627370496p-52"},
	// æµ‹è¯•æµ®ç‚¹æ•°ä¸­ä½¿ç”¨çš„sharpæ ‡å¿—ã€‚. md5:c7ce62d50d03fd2a
	{"%#g", 1e-323, "1.00000e-323"},
	{"%#g", -1.0, "-1.00000"},
	{"%#g", 1.1, "1.10000"},
	{"%#g", 123456.0, "123456."},
	{"%#g", 1234567.0, "1.234567e+06"},
	{"%#g", 1230000.0, "1.23000e+06"},
	{"%#g", 1000000.0, "1.00000e+06"},
	{"%#.0f", 1.0, "1."},
	{"%#.0e", 1.0, "1.e+00"},
	{"%#.0x", 1.0, "0x1.p+00"},
	{"%#.0g", 1.0, "1."},
	{"%#.0g", 1100000.0, "1.e+06"},
	{"%#.4f", 1.0, "1.0000"},
	{"%#.4e", 1.0, "1.0000e+00"},
	{"%#.4x", 1.0, "0x1.0000p+00"},
	{"%#.4g", 1.0, "1.000"},
	{"%#.4g", 100000.0, "1.000e+05"},
	{"%#.4g", 1.234, "1.234"},
	{"%#.4g", 0.1234, "0.1234"},
	{"%#.4g", 1.23, "1.230"},
	{"%#.4g", 0.123, "0.1230"},
	{"%#.4g", 1.2, "1.200"},
	{"%#.4g", 0.12, "0.1200"},
	{"%#.4g", 10.2, "10.20"},
	{"%#.4g", 0.0, "0.000"},
	{"%#.4g", 0.012, "0.01200"},
	{"%#.0f", 123.0, "123."},
	{"%#.0e", 123.0, "1.e+02"},
	{"%#.0x", 123.0, "0x1.p+07"},
	{"%#.0g", 123.0, "1.e+02"},
	{"%#.4f", 123.0, "123.0000"},
	{"%#.4e", 123.0, "1.2300e+02"},
	{"%#.4x", 123.0, "0x1.ec00p+06"},
	{"%#.4g", 123.0, "123.0"},
	{"%#.4g", 123000.0, "1.230e+05"},
	{"%#9.4g", 1.0, "    1.000"},
	// å°–å³°æ ‡å¿—å¯¹äºŒè¿›åˆ¶æµ®ç‚¹æ ¼å¼æ²¡æœ‰å½±å“ã€‚. md5:529fed249f6eea8f
	{"%#b", 1.0, "4503599627370496p-52"},
	// ç²¾åº¦å¯¹äºŒè¿›åˆ¶æµ®ç‚¹æ ¼å¼æ²¡æœ‰å½±å“ã€‚. md5:393e6f53d4dd83a9
	{"%.4b", float32(1.0), "8388608p-23"},
	{"%.4b", -1.0, "-4503599627370496p-52"},
	// æµ‹è¯•f.intbufè¾¹ç•Œæ£€æŸ¥çš„æ­£ç¡®æ€§ã€‚. md5:163a76ec1df687fe
	{"%.68f", 1.0, zeroFill("1.", 68, "")},
	{"%.68f", -1.0, zeroFill("-1.", 68, "")},
	// æµ®ç‚¹æ•°çš„æ— ç©·å¤§å’ŒNaNï¼ˆéæ•°å­—ï¼‰. md5:19bfeced45fe6478
	{"%f", posInf, "+Inf"},
	{"%.1f", negInf, "-Inf"},
	{"% f", NaN, " NaN"},
	{"%20f", posInf, "                +Inf"},
	{"% 20F", posInf, "                 Inf"},
	{"% 20e", negInf, "                -Inf"},
	{"% 20x", negInf, "                -Inf"},
	{"%+20E", negInf, "                -Inf"},
	{"%+20X", negInf, "                -Inf"},
	{"% +20g", negInf, "                -Inf"},
	{"%+-20G", posInf, "+Inf                "},
	{"%20e", NaN, "                 NaN"},
	{"%20x", NaN, "                 NaN"},
	{"% +20E", NaN, "                +NaN"},
	{"% +20X", NaN, "                +NaN"},
	{"% -20g", NaN, " NaN                "},
	{"%+-20G", NaN, "+NaN                "},
	// é›¶å¡«å……ä¸é€‚ç”¨äºæ— ç©·å¤§å’ŒNaNã€‚. md5:0f35f381c57ccf6e
	{"%+020e", posInf, "                +Inf"},
	{"%+020x", posInf, "                +Inf"},
	{"%-020f", negInf, "-Inf                "},
	{"%-020E", NaN, "NaN                 "},
	{"%-020X", NaN, "NaN                 "},

	// complex values
	{"%.f", 0i, "(0+0i)"},
	{"% .f", 0i, "( 0+0i)"},
	{"%+.f", 0i, "(+0+0i)"},
	{"% +.f", 0i, "(+0+0i)"},
	{"%+.3e", 0i, "(+0.000e+00+0.000e+00i)"},
	{"%+.3x", 0i, "(+0x0.000p+00+0x0.000p+00i)"},
	{"%+.3f", 0i, "(+0.000+0.000i)"},
	{"%+.3g", 0i, "(+0+0i)"},
	{"%+.3e", 1 + 2i, "(+1.000e+00+2.000e+00i)"},
	{"%+.3x", 1 + 2i, "(+0x1.000p+00+0x1.000p+01i)"},
	{"%+.3f", 1 + 2i, "(+1.000+2.000i)"},
	{"%+.3g", 1 + 2i, "(+1+2i)"},
	{"%.3e", 0i, "(0.000e+00+0.000e+00i)"},
	{"%.3x", 0i, "(0x0.000p+00+0x0.000p+00i)"},
	{"%.3f", 0i, "(0.000+0.000i)"},
	{"%.3F", 0i, "(0.000+0.000i)"},
	{"%.3F", complex64(0i), "(0.000+0.000i)"},
	{"%.3g", 0i, "(0+0i)"},
	{"%.3e", 1 + 2i, "(1.000e+00+2.000e+00i)"},
	{"%.3x", 1 + 2i, "(0x1.000p+00+0x1.000p+01i)"},
	{"%.3f", 1 + 2i, "(1.000+2.000i)"},
	{"%.3g", 1 + 2i, "(1+2i)"},
	{"%.3e", -1 - 2i, "(-1.000e+00-2.000e+00i)"},
	{"%.3x", -1 - 2i, "(-0x1.000p+00-0x1.000p+01i)"},
	{"%.3f", -1 - 2i, "(-1.000-2.000i)"},
	{"%.3g", -1 - 2i, "(-1-2i)"},
	{"% .3E", -1 - 2i, "(-1.000E+00-2.000E+00i)"},
	{"% .3X", -1 - 2i, "(-0X1.000P+00-0X1.000P+01i)"},
	{"%+.3g", 1 + 2i, "(+1+2i)"},
	{"%+.3g", complex64(1 + 2i), "(+1+2i)"},
	{"%#g", 1 + 2i, "(1.00000+2.00000i)"},
	{"%#g", 123456 + 789012i, "(123456.+789012.i)"},
	{"%#g", 1e-10i, "(0.00000+1.00000e-10i)"},
	{"%#g", -1e10 - 1.11e100i, "(-1.00000e+10-1.11000e+100i)"},
	{"%#.0f", 1.23 + 1.0i, "(1.+1.i)"},
	{"%#.0e", 1.23 + 1.0i, "(1.e+00+1.e+00i)"},
	{"%#.0x", 1.23 + 1.0i, "(0x1.p+00+0x1.p+00i)"},
	{"%#.0g", 1.23 + 1.0i, "(1.+1.i)"},
	{"%#.0g", 0 + 100000i, "(0.+1.e+05i)"},
	{"%#.0g", 1230000 + 0i, "(1.e+06+0.i)"},
	{"%#.4f", 1 + 1.23i, "(1.0000+1.2300i)"},
	{"%#.4e", 123 + 1i, "(1.2300e+02+1.0000e+00i)"},
	{"%#.4x", 123 + 1i, "(0x1.ec00p+06+0x1.0000p+00i)"},
	{"%#.4g", 123 + 1.23i, "(123.0+1.230i)"},
	{"%#12.5g", 0 + 100000i, "(      0.0000 +1.0000e+05i)"},
	{"%#12.5g", 1230000 - 0i, "(  1.2300e+06     +0.0000i)"},
	{"%b", 1 + 2i, "(4503599627370496p-52+4503599627370496p-51i)"},
	{"%b", complex64(1 + 2i), "(8388608p-23+8388608p-22i)"},
	// å°–å³°æ ‡å¿—å¯¹äºŒè¿›åˆ¶å¤æ•°æ ¼å¼æ²¡æœ‰å½±å“ã€‚. md5:5a17eaa8bd9da0ab
	{"%#b", 1 + 2i, "(4503599627370496p-52+4503599627370496p-51i)"},
	// ç²¾åº¦å¯¹äºŒè¿›åˆ¶å¤æ•°æ ¼å¼æ²¡æœ‰å½±å“ã€‚. md5:7428a8f9950bcd16
	{"%.4b", 1 + 2i, "(4503599627370496p-52+4503599627370496p-51i)"},
	{"%.4b", complex64(1 + 2i), "(8388608p-23+8388608p-22i)"},
	// å¤æ•°æ— ç©·å¤§å’ŒNaNs. md5:e32d7333c8cfdb51
	{"%f", complex(posInf, posInf), "(+Inf+Infi)"},
	{"%f", complex(negInf, negInf), "(-Inf-Infi)"},
	{"%f", complex(NaN, NaN), "(NaN+NaNi)"},
	{"%.1f", complex(posInf, posInf), "(+Inf+Infi)"},
	{"% f", complex(posInf, posInf), "( Inf+Infi)"},
	{"% f", complex(negInf, negInf), "(-Inf-Infi)"},
	{"% f", complex(NaN, NaN), "( NaN+NaNi)"},
	{"%8e", complex(posInf, posInf), "(    +Inf    +Infi)"},
	{"%8x", complex(posInf, posInf), "(    +Inf    +Infi)"},
	{"% 8E", complex(posInf, posInf), "(     Inf    +Infi)"},
	{"% 8X", complex(posInf, posInf), "(     Inf    +Infi)"},
	{"%+8f", complex(negInf, negInf), "(    -Inf    -Infi)"},
	{"% +8g", complex(negInf, negInf), "(    -Inf    -Infi)"},
	{"% -8G", complex(NaN, NaN), "( NaN    +NaN    i)"},
	{"%+-8b", complex(NaN, NaN), "(+NaN    +NaN    i)"},
	// é›¶å¡«å……ä¸é€‚ç”¨äºæ— ç©·å¤§å’ŒNaNã€‚. md5:0f35f381c57ccf6e
	{"%08f", complex(posInf, posInf), "(    +Inf    +Infi)"},
	{"%-08g", complex(negInf, negInf), "(-Inf    -Inf    i)"},
	{"%-08G", complex(NaN, NaN), "(NaN     +NaN    i)"},

	// old test/fmt_test.go
	{"%e", 1.0, "1.000000e+00"},
	{"%e", 1234.5678e3, "1.234568e+06"},
	{"%e", 1234.5678e-8, "1.234568e-05"},
	{"%e", -7.0, "-7.000000e+00"},
	{"%e", -1e-9, "-1.000000e-09"},
	{"%f", 1234.5678e3, "1234567.800000"},
	{"%f", 1234.5678e-8, "0.000012"},
	{"%f", -7.0, "-7.000000"},
	{"%f", -1e-9, "-0.000000"},
	{"%g", 1234.5678e3, "1.2345678e+06"},
	{"%g", float32(1234.5678e3), "1.2345678e+06"},
	{"%g", 1234.5678e-8, "1.2345678e-05"},
	{"%g", -7.0, "-7"},
	{"%g", -1e-9, "-1e-09"},
	{"%g", float32(-1e-9), "-1e-09"},
	{"%E", 1.0, "1.000000E+00"},
	{"%E", 1234.5678e3, "1.234568E+06"},
	{"%E", 1234.5678e-8, "1.234568E-05"},
	{"%E", -7.0, "-7.000000E+00"},
	{"%E", -1e-9, "-1.000000E-09"},
	{"%G", 1234.5678e3, "1.2345678E+06"},
	{"%G", float32(1234.5678e3), "1.2345678E+06"},
	{"%G", 1234.5678e-8, "1.2345678E-05"},
	{"%G", -7.0, "-7"},
	{"%G", -1e-9, "-1E-09"},
	{"%G", float32(-1e-9), "-1E-09"},
	{"%20.5s", "qwertyuiop", "               qwert"},
	{"%.5s", "qwertyuiop", "qwert"},
	{"%-20.5s", "qwertyuiop", "qwert               "},
	{"%20c", 'x', "                   x"},
	{"%-20c", 'x', "x                   "},
	{"%20.6e", 1.2345e3, "        1.234500e+03"},
	{"%20.6e", 1.2345e-3, "        1.234500e-03"},
	{"%20e", 1.2345e3, "        1.234500e+03"},
	{"%20e", 1.2345e-3, "        1.234500e-03"},
	{"%20.8e", 1.2345e3, "      1.23450000e+03"},
	{"%20f", 1.23456789e3, "         1234.567890"},
	{"%20f", 1.23456789e-3, "            0.001235"},
	{"%20f", 12345678901.23456789, "  12345678901.234568"},
	{"%-20f", 1.23456789e3, "1234.567890         "},
	{"%20.8f", 1.23456789e3, "       1234.56789000"},
	{"%20.8f", 1.23456789e-3, "          0.00123457"},
	{"%g", 1.23456789e3, "1234.56789"},
	{"%g", 1.23456789e-3, "0.00123456789"},
	{"%g", 1.23456789e20, "1.23456789e+20"},

	// arrays
	{"%v", array, "[1 2 3 4 5]"},
	{"%v", iarray, "[1 hello 2.5 <nil>]"},
	{"%v", barray, "[1 2 3 4 5]"},
	{"%v", &array, "&[1 2 3 4 5]"},
	{"%v", &iarray, "&[1 hello 2.5 <nil>]"},
	{"%v", &barray, "&[1 2 3 4 5]"},

	// slices
	{"%v", slice, "[1 2 3 4 5]"},
	{"%v", islice, "[1 hello 2.5 <nil>]"},
	{"%v", bslice, "[1 2 3 4 5]"},
	{"%v", &slice, "&[1 2 3 4 5]"},
	{"%v", &islice, "&[1 hello 2.5 <nil>]"},
	{"%v", &bslice, "&[1 2 3 4 5]"},

	// ä¸ %b, %c, %d, %o, %U å’Œ %v å…³è”çš„å­—èŠ‚æ•°ç»„å’Œåˆ‡ç‰‡. md5:c16fef7931ed6c04
	{"%b", [3]byte{65, 66, 67}, "[1000001 1000010 1000011]"},
	{"%c", [3]byte{65, 66, 67}, "[A B C]"},
	{"%d", [3]byte{65, 66, 67}, "[65 66 67]"},
	{"%o", [3]byte{65, 66, 67}, "[101 102 103]"},
	{"%U", [3]byte{65, 66, 67}, "[U+0041 U+0042 U+0043]"},
	{"%v", [3]byte{65, 66, 67}, "[65 66 67]"},
	{"%v", [1]byte{123}, "[123]"},
	{"%012v", []byte{}, "[]"},
	{"%#012v", []byte{}, "[]byte{}"},
	{"%6v", []byte{1, 11, 111}, "[     1     11    111]"},
	{"%06v", []byte{1, 11, 111}, "[000001 000011 000111]"},
	{"%-6v", []byte{1, 11, 111}, "[1      11     111   ]"},
	{"%-06v", []byte{1, 11, 111}, "[1      11     111   ]"},
	{"%#v", []byte{1, 11, 111}, "[]byte{0x1, 0xb, 0x6f}"},
	{"%#6v", []byte{1, 11, 111}, "[]byte{   0x1,    0xb,   0x6f}"},
	{"%#06v", []byte{1, 11, 111}, "[]byte{0x000001, 0x00000b, 0x00006f}"},
	{"%#-6v", []byte{1, 11, 111}, "[]byte{0x1   , 0xb   , 0x6f  }"},
	{"%#-06v", []byte{1, 11, 111}, "[]byte{0x1   , 0xb   , 0x6f  }"},
	// f.spaceå’Œf.plusåº”è¯¥å¯¹%væ²¡æœ‰å½±å“ã€‚. md5:068db9ba1113b797
	{"% v", []byte{1, 11, 111}, "[ 1  11  111]"},
	{"%+v", [3]byte{1, 11, 111}, "[1 11 111]"},
	{"%# -6v", []byte{1, 11, 111}, "[]byte{ 0x1  ,  0xb  ,  0x6f }"},
	{"%#+-6v", [3]byte{1, 11, 111}, "[3]uint8{0x1   , 0xb   , 0x6f  }"},
	// f.space å’Œ f.plus åº”å½“å¯¹ %d èµ·ä½œç”¨ã€‚. md5:1a75e496c2703ffa
	{"% d", []byte{1, 11, 111}, "[ 1  11  111]"},
	{"%+d", [3]byte{1, 11, 111}, "[+1 +11 +111]"},
	{"%# -6d", []byte{1, 11, 111}, "[ 1      11     111  ]"},
	{"%#+-6d", [3]byte{1, 11, 111}, "[+1     +11    +111  ]"},

	// floates with %v
	{"%v", 1.2345678, "1.2345678"},
	{"%v", float32(1.2345678), "1.2345678"},

	// complexes with %v
	{"%v", 1 + 2i, "(1+2i)"},
	{"%v", complex64(1 + 2i), "(1+2i)"},

	// structs
	{"%v", A{1, 2, "a", []int{1, 2}}, `{1 2 a [1 2]}`},
	{"%+v", A{1, 2, "a", []int{1, 2}}, `{i:1 j:2 s:a x:[1 2]}`},

	// +v åœ¨åŒ…å«å¯æ‰“å°é¡¹çš„ç»“æ„ä½“ä¸Š. md5:4abb2b10afc9883c
	{"%+v", B{1, 2}, `{I:<1> j:2}`},
	{"%+v", C{1, B{2, 3}}, `{i:1 B:{I:<2> j:3}}`},

	// å¯¹Stringableç±»å‹çš„å…¶ä»–æ ¼å¼. md5:804ca88a9d116b3a
	{"%s", I(23), `<23>`},
	{"%q", I(23), `"<23>"`},
	{"%x", I(23), `3c32333e`},
	{"%#x", I(23), `0x3c32333e`},
	{"%# x", I(23), `0x3c 0x32 0x33 0x3e`},
	// Stringer ä»…é€‚ç”¨äºå­—ç¬¦ä¸²æ ¼å¼ã€‚. md5:166e200c8e9b04dd
	{"%d", I(23), `23`},
	// Stringer åº”ç”¨äºæå–çš„å€¼ã€‚. md5:2bfa36aabd9035aa
	{"%s", reflect.ValueOf(I(23)), `<23>`},

	// go syntax
	{"%#v", A{1, 2, "a", []int{1, 2}}, `fmt_test.A{i:1, j:0x2, s:"a", x:[]int{1, 2}}`},
	{"%#v", new(byte), "(*uint8)(0xPTR)"},
	{"%#v", TestFmtInterface, "(func(*testing.T))(0xPTR)"},
	{"%#v", make(chan int), "(chan int)(0xPTR)"},
	{"%#v", uint64(1<<64 - 1), "0xffffffffffffffff"},
	{"%#v", 1000000000, "1000000000"},
	{"%#v", map[string]int{"a": 1}, `map[string]int{"a":1}`},
	{"%#v", map[string]B{"a": {1, 2}}, `map[string]fmt_test.B{"a":fmt_test.B{I:1, j:2}}`},
	{"%#v", []string{"a", "b"}, `[]string{"a", "b"}`},
	{"%#v", SI{}, `fmt_test.SI{I:interface {}(nil)}`},
	{"%#v", []int(nil), `[]int(nil)`},
	{"%#v", []int{}, `[]int{}`},
	{"%#v", array, `[5]int{1, 2, 3, 4, 5}`},
	{"%#v", &array, `&[5]int{1, 2, 3, 4, 5}`},
	{"%#v", iarray, `[4]interface {}{1, "hello", 2.5, interface {}(nil)}`},
	{"%#v", &iarray, `&[4]interface {}{1, "hello", 2.5, interface {}(nil)}`},
	{"%#v", map[int]byte(nil), `map[int]uint8(nil)`},
	{"%#v", map[int]byte{}, `map[int]uint8{}`},
	{"%#v", "foo", `"foo"`},
	{"%#v", barray, `[5]fmt_test.renamedUint8{0x1, 0x2, 0x3, 0x4, 0x5}`},
	{"%#v", bslice, `[]fmt_test.renamedUint8{0x1, 0x2, 0x3, 0x4, 0x5}`},
	{"%#v", []int32(nil), "[]int32(nil)"},
	{"%#v", 1.2345678, "1.2345678"},
	{"%#v", float32(1.2345678), "1.2345678"},

	// å®Œå…¨æ•°æµ®ç‚¹æ•°ä»¥æ•´æ•°å½¢å¼æ‰“å°ï¼Œä¸å¸¦å°æ•°éƒ¨åˆ†ã€‚å‚è§é—®é¢˜27634ã€‚. md5:3d24e1b73d5a4878
	{"%#v", 1.0, "1"},
	{"%#v", 1000000.0, "1e+06"},
	{"%#v", float32(1.0), "1"},
	{"%#v", float32(1000000.0), "1e+06"},

	// åªæœ‰åœ¨é¡¶çº§å‡ºç°[]byteå’Œ[]uint8æ—¶ï¼Œæ‰å°†å®ƒä»¬ä½œä¸ºç±»å‹[]byteè¿›è¡Œæ‰“å°ã€‚. md5:6a66f14eeec9f3b5
	{"%#v", []byte(nil), "[]byte(nil)"},
	{"%#v", []uint8(nil), "[]byte(nil)"},
	{"%#v", []byte{}, "[]byte{}"},
	{"%#v", []uint8{}, "[]byte{}"},
	{"%#v", reflect.ValueOf([]byte{}), "[]uint8{}"},
	{"%#v", reflect.ValueOf([]uint8{}), "[]uint8{}"},
	{"%#v", &[]byte{}, "&[]uint8{}"},
	{"%#v", &[]byte{}, "&[]uint8{}"},
	{"%#v", [3]byte{}, "[3]uint8{0x0, 0x0, 0x0}"},
	{"%#v", [3]uint8{}, "[3]uint8{0x0, 0x0, 0x0}"},

	// å…¶ä»–æ ¼å¼çš„åˆ‡ç‰‡. md5:596a58ca6b628cb1
	{"%#x", []int{1, 2, 15}, `[0x1 0x2 0xf]`},
	{"%x", []int{1, 2, 15}, `[1 2 f]`},
	{"%d", []int{1, 2, 15}, `[1 2 15]`},
	{"%d", []byte{1, 2, 15}, `[1 2 15]`},
	{"%q", []string{"a", "b"}, `["a" "b"]`},
	{"% 02x", []byte{1}, "01"},
	{"% 02x", []byte{1, 2, 3}, "01 02 03"},

	// ä½¿ç”¨å­—èŠ‚åˆ‡ç‰‡è¿›è¡Œå¡«å……ã€‚. md5:87d6a838449d19c8
	{"%2x", []byte{}, "  "},
	{"%#2x", []byte{}, "  "},
	{"% 02x", []byte{}, "00"},
	{"%# 02x", []byte{}, "00"},
	{"%-2x", []byte{}, "  "},
	{"%-02x", []byte{}, "  "},
	{"%8x", []byte{0xab}, "      ab"},
	{"% 8x", []byte{0xab}, "      ab"},
	{"%#8x", []byte{0xab}, "    0xab"},
	{"%# 8x", []byte{0xab}, "    0xab"},
	{"%08x", []byte{0xab}, "000000ab"},
	{"% 08x", []byte{0xab}, "000000ab"},
	{"%#08x", []byte{0xab}, "00000xab"},
	{"%# 08x", []byte{0xab}, "00000xab"},
	{"%10x", []byte{0xab, 0xcd}, "      abcd"},
	{"% 10x", []byte{0xab, 0xcd}, "     ab cd"},
	{"%#10x", []byte{0xab, 0xcd}, "    0xabcd"},
	{"%# 10x", []byte{0xab, 0xcd}, " 0xab 0xcd"},
	{"%010x", []byte{0xab, 0xcd}, "000000abcd"},
	{"% 010x", []byte{0xab, 0xcd}, "00000ab cd"},
	{"%#010x", []byte{0xab, 0xcd}, "00000xabcd"},
	{"%# 010x", []byte{0xab, 0xcd}, "00xab 0xcd"},
	{"%-10X", []byte{0xab}, "AB        "},
	{"% -010X", []byte{0xab}, "AB        "},
	{"%#-10X", []byte{0xab, 0xcd}, "0XABCD    "},
	{"%# -010X", []byte{0xab, 0xcd}, "0XAB 0XCD "},
	// Same for strings
	{"%2x", "", "  "},
	{"%#2x", "", "  "},
	{"% 02x", "", "00"},
	{"%# 02x", "", "00"},
	{"%-2x", "", "  "},
	{"%-02x", "", "  "},
	{"%8x", "\xab", "      ab"},
	{"% 8x", "\xab", "      ab"},
	{"%#8x", "\xab", "    0xab"},
	{"%# 8x", "\xab", "    0xab"},
	{"%08x", "\xab", "000000ab"},
	{"% 08x", "\xab", "000000ab"},
	{"%#08x", "\xab", "00000xab"},
	{"%# 08x", "\xab", "00000xab"},
	{"%10x", "\xab\xcd", "      abcd"},
	{"% 10x", "\xab\xcd", "     ab cd"},
	{"%#10x", "\xab\xcd", "    0xabcd"},
	{"%# 10x", "\xab\xcd", " 0xab 0xcd"},
	{"%010x", "\xab\xcd", "000000abcd"},
	{"% 010x", "\xab\xcd", "00000ab cd"},
	{"%#010x", "\xab\xcd", "00000xabcd"},
	{"%# 010x", "\xab\xcd", "00xab 0xcd"},
	{"%-10X", "\xab", "AB        "},
	{"% -010X", "\xab", "AB        "},
	{"%#-10X", "\xab\xcd", "0XABCD    "},
	{"%# -010X", "\xab\xcd", "0XAB 0XCD "},

	// renamings
	{"%v", renamedBool(true), "true"},
	{"%d", renamedBool(true), "%!d(fmt_test.renamedBool=true)"},
	{"%o", renamedInt(8), "10"},
	{"%d", renamedInt8(-9), "-9"},
	{"%v", renamedInt16(10), "10"},
	{"%v", renamedInt32(-11), "-11"},
	{"%X", renamedInt64(255), "FF"},
	{"%v", renamedUint(13), "13"},
	{"%o", renamedUint8(14), "16"},
	{"%X", renamedUint16(15), "F"},
	{"%d", renamedUint32(16), "16"},
	{"%X", renamedUint64(17), "11"},
	{"%o", renamedUintptr(18), "22"},
	{"%x", renamedString("thing"), "7468696e67"},
	{"%d", renamedBytes([]byte{1, 2, 15}), `[1 2 15]`},
	{"%q", renamedBytes([]byte("hello")), `"hello"`},
	{"%x", []renamedUint8{'h', 'e', 'l', 'l', 'o'}, "68656c6c6f"},
	{"%X", []renamedUint8{'h', 'e', 'l', 'l', 'o'}, "68656C6C6F"},
	{"%s", []renamedUint8{'h', 'e', 'l', 'l', 'o'}, "hello"},
	{"%q", []renamedUint8{'h', 'e', 'l', 'l', 'o'}, `"hello"`},
	{"%v", renamedFloat32(22), "22"},
	{"%v", renamedFloat64(33), "33"},
	{"%v", renamedComplex64(3 + 4i), "(3+4i)"},
	{"%v", renamedComplex128(4 - 3i), "(4-3i)"},

	// Formatter
	{"%x", F(1), "<x=F(1)>"},
	{"%x", G(2), "2"},
	{"%+v", S{F(4), G(5)}, "{F:<v=F(4)> G:5}"},

	// GoStringer
	{"%#v", G(6), "GoString(6)"},
	{"%#v", S{F(7), G(8)}, "fmt_test.S{F:<v=F(7)>, G:GoString(8)}"},

	// %T
	{"%T", byte(0), "uint8"},
	{"%T", reflect.ValueOf(nil), "reflect.Value"},
	{"%T", (4 - 3i), "complex128"},
	{"%T", renamedComplex128(4 - 3i), "fmt_test.renamedComplex128"},
	{"%T", intVar, "int"},
	{"%6T", &intVar, "  *int"},
	{"%10T", nil, "     <nil>"},
	{"%-10T", nil, "<nil>     "},

	// %p with pointers
	{"%p", (*int)(nil), "0x0"},
	{"%#p", (*int)(nil), "0"},
	{"%p", &intVar, "0xPTR"},
	{"%#p", &intVar, "PTR"},
	{"%p", &array, "0xPTR"},
	{"%p", &slice, "0xPTR"},
	{"%8.2p", (*int)(nil), "    0x00"},
	{"%-20.16p", &intVar, "0xPTR  "},
	// %p on non-pointers
	{"%p", make(chan int), "0xPTR"},
	{"%p", make(map[int]int), "0xPTR"},
	{"%p", func() {}, "0xPTR"},
	{"%p", 27, "%!p(int=27)"},  // not a pointer at all
	{"%p", nil, "%!p(<nil>)"},  // nilæœ¬èº«æ²¡æœ‰ç±»å‹.... md5:e8974e42e6290323
	{"%#p", nil, "%!p(<nil>)"}, // å› æ­¤å®ƒä¸æ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹ã€‚. md5:0cfabb45fd59930e
	// æŒ‡é’ˆä¸ç‰¹å®šåŸºå€. md5:9de4be58346b82c0
	{"%b", &intVar, "PTR_b"},
	{"%d", &intVar, "PTR_d"},
	{"%o", &intVar, "PTR_o"},
	{"%x", &intVar, "PTR_x"},
	{"%X", &intVar, "PTR_X"},
	// %v on pointers
	{"%v", nil, "<nil>"},
	{"%#v", nil, "<nil>"},
	{"%v", (*int)(nil), "<nil>"},
	{"%#v", (*int)(nil), "(*int)(nil)"},
	{"%v", &intVar, "0xPTR"},
	{"%#v", &intVar, "(*int)(0xPTR)"},
	{"%8.2v", (*int)(nil), "   <nil>"},
	{"%-20.16v", &intVar, "0xPTR  "},
	// æŒ‡é’ˆä¸Šçš„å­—ç¬¦ä¸²æ–¹æ³•. md5:8c023bfe28cba065
	{"%s", &pValue, "String(p)"}, // String method...
	{"%p", &pValue, "0xPTR"},     // ... ä¸ä¼šä½¿ç”¨ %p è°ƒç”¨ã€‚. md5:4318cf71cb5622c3

	// å¦‚æœStringerå¯ä»¥ï¼Œ%dåº”è¯¥ç»™å‡ºæ•´æ•°. md5:9771b0ed2261119a
	{"%s", time.Time{}.Month(), "January"},
	{"%d", time.Time{}.Month(), "1"},

	// erroneous things
	{"", nil, "%!(EXTRA <nil>)"},
	{"", 2, "%!(EXTRA int=2)"},
	{"no args", "hello", "no args%!(EXTRA string=hello)"},
	{"%s %", "hello", "hello %!(NOVERB)"},
	{"%s %.2", "hello", "hello %!(NOVERB)"},
	{"%017091901790959340919092959340919017929593813360", 0, "%!(NOVERB)%!(EXTRA int=0)"},
	{"%184467440737095516170v", 0, "%!(NOVERB)%!(EXTRA int=0)"},
	// é¢å¤–å‚æ•°é”™è¯¯åº”è¯¥åœ¨ä¸è®¾ç½®æ ‡å¿—çš„æƒ…å†µä¸‹è¿›è¡Œæ ¼å¼åŒ–ã€‚. md5:6c1f678ff096a565
	{"%010.2", "12345", "%!(NOVERB)%!(EXTRA string=12345)"},

	// æµ‹è¯•éè‡ªåé”®çš„æ˜ å°„èƒ½å¦æ‰“å°æ‰€æœ‰é”®å’Œå€¼ã€‚. md5:dd521c24773421c2
	{"%v", map[float64]int{NaN: 1, NaN: 1}, "map[NaN:1 NaN:1]"},

	// ä¸Cè¯­è¨€çš„printfå‡½æ•°æ ¼å¼åŒ–å¡«å……è§„åˆ™è¿›è¡Œæ¯”è¾ƒã€‚. md5:862bcbe6e5fedea8
	/*
		C program:
		#include <stdio.h>

		char *format[] = {
			"[%.2f]",
			"[% .2f]",
			"[%+.2f]",
			"[%7.2f]",
			"[% 7.2f]",
			"[%+7.2f]",
			"[% +7.2f]",
			"[%07.2f]",
			"[% 07.2f]",
			"[%+07.2f]",
			"[% +07.2f]"
		};

		int main(void) {
			int i;
			for(i = 0; i < 11; i++) {
				printf("%s: ", format[i]);
				printf(format[i], 1.0);
				printf(" ");
				printf(format[i], -1.0);
				printf("\n");
			}
		}

		Output:
			[%.2f]: [1.00] [-1.00]
			[% .2f]: [ 1.00] [-1.00]
			[%+.2f]: [+1.00] [-1.00]
			[%7.2f]: [   1.00] [  -1.00]
			[% 7.2f]: [   1.00] [  -1.00]
			[%+7.2f]: [  +1.00] [  -1.00]
			[% +7.2f]: [  +1.00] [  -1.00]
			[%07.2f]: [0001.00] [-001.00]
			[% 07.2f]: [ 001.00] [-001.00]
			[%+07.2f]: [+001.00] [-001.00]
			[% +07.2f]: [+001.00] [-001.00]

	*/
	{"%.2f", 1.0, "1.00"},
	{"%.2f", -1.0, "-1.00"},
	{"% .2f", 1.0, " 1.00"},
	{"% .2f", -1.0, "-1.00"},
	{"%+.2f", 1.0, "+1.00"},
	{"%+.2f", -1.0, "-1.00"},
	{"%7.2f", 1.0, "   1.00"},
	{"%7.2f", -1.0, "  -1.00"},
	{"% 7.2f", 1.0, "   1.00"},
	{"% 7.2f", -1.0, "  -1.00"},
	{"%+7.2f", 1.0, "  +1.00"},
	{"%+7.2f", -1.0, "  -1.00"},
	{"% +7.2f", 1.0, "  +1.00"},
	{"% +7.2f", -1.0, "  -1.00"},
	{"%07.2f", 1.0, "0001.00"},
	{"%07.2f", -1.0, "-001.00"},
	{"% 07.2f", 1.0, " 001.00"},
	{"% 07.2f", -1.0, "-001.00"},
	{"%+07.2f", 1.0, "+001.00"},
	{"%+07.2f", -1.0, "-001.00"},
	{"% +07.2f", 1.0, "+001.00"},
	{"% +07.2f", -1.0, "-001.00"},

	// å¤æ•°ï¼šåœ¨TestComplexFormattingä¸­è¿›è¡Œäº†è¯¦å°½çš„æµ‹è¯•ã€‚. md5:664caeb88491f1cd
	{"%7.2f", 1 + 2i, "(   1.00  +2.00i)"},
	{"%+07.2f", -1 - 2i, "(-001.00-002.00i)"},

	// å¦‚æœéœ€è¦å‘å³å¡«å……ï¼Œè¯·ä½¿ç”¨ç©ºæ ¼ä»£æ›¿0ã€‚. md5:1be62c0543bb9239
	{"%0-5s", "abc", "abc  "},
	{"%-05.1f", 1.0, "1.0  "},

	// æµ®ç‚¹æ•°å’Œå¤æ•°çš„æ ¼å¼åŒ–ä¸åº”æ”¹å˜å…¶ä»–å…ƒç´ çš„å¡«å……å®½åº¦ã€‚å‚è§é—®é¢˜ 14642ã€‚
	// md5:439398b6d06f2102
	{"%06v", []any{+10.0, 10}, "[000010 000010]"},
	{"%06v", []any{-10.0, 10}, "[-00010 000010]"},
	{"%06v", []any{+10.0 + 10i, 10}, "[(000010+00010i) 000010]"},
	{"%06v", []any{-10.0 + 10i, 10}, "[(-00010+00010i) 000010]"},

	// æ•´æ•°æ ¼å¼åŒ–ä¸åº”è¯¥æ”¹å˜å…¶ä»–å…ƒç´ çš„å¡«å……ã€‚. md5:350ce4fb57cac29b
	{"%03.6v", []any{1, 2.0, "x"}, "[000001 002 00x]"},
	{"%03.0v", []any{0, 2.0, "x"}, "[    002 000]"},

	// ä½¿ç”¨å¤æ‚çš„æ ¼å¼åŒ–é€‰é¡¹ï¼Œä»¥ä¾¿åœ¨æ•°ç»„çš„åç»­æ¡ç›®ä¸­ä¿ç•™åŠ å·æ ‡å¿—ï¼Œè¿™æ ·ä¼šæ˜¾ç¤ºä¸º +2+0i å’Œ +3+0i è€Œä¸æ˜¯ 2+0i å’Œ 3+0iã€‚
	// md5:5556f06edd7c4b3d
	{"%v", []complex64{1, 2, 3}, "[(1+0i) (2+0i) (3+0i)]"},
	{"%v", []complex128{1, 2, 3}, "[(1+0i) (2+0i) (3+0i)]"},

	// ä¸å®Œæ•´çš„æ ¼å¼è¯´æ˜å¯¼è‡´äº†å´©æºƒã€‚. md5:e416c8bd61ffefa1
	{"%.", 3, "%!.(int=3)"},

	// å¤æ•°çš„å¡«å……ã€‚æ›¾å­˜åœ¨é—®é¢˜ï¼Œç„¶åè¢«ä¿®å¤ï¼Œä½†éšååˆå‡ºç°äº†é—®é¢˜ã€‚. md5:d10742a3da07ff00
	{"%+10.2f", +104.66 + 440.51i, "(   +104.66   +440.51i)"},
	{"%+10.2f", -104.66 + 440.51i, "(   -104.66   +440.51i)"},
	{"%+10.2f", +104.66 - 440.51i, "(   +104.66   -440.51i)"},
	{"%+10.2f", -104.66 - 440.51i, "(   -104.66   -440.51i)"},
	{"%+010.2f", +104.66 + 440.51i, "(+000104.66+000440.51i)"},
	{"%+010.2f", -104.66 + 440.51i, "(-000104.66+000440.51i)"},
	{"%+010.2f", +104.66 - 440.51i, "(+000104.66-000440.51i)"},
	{"%+010.2f", -104.66 - 440.51i, "(-000104.66-000440.51i)"},

	// []Tï¼Œå…¶ä¸­ç±»å‹Tæ˜¯ä¸€ä¸ªå…·æœ‰Stringeræ–¹æ³•çš„å­—èŠ‚ã€‚. md5:b82654802b5d90a1
	{"%v", byteStringerSlice, "[X X X X X]"},
	{"%s", byteStringerSlice, "hello"},
	{"%q", byteStringerSlice, "\"hello\""},
	{"%x", byteStringerSlice, "68656c6c6f"},
	{"%X", byteStringerSlice, "68656C6C6F"},
	{"%#v", byteStringerSlice, "[]fmt_test.byteStringer{0x68, 0x65, 0x6c, 0x6c, 0x6f}"},

	// å¯¹Formatterä¹Ÿæ˜¯å¦‚æ­¤ã€‚. md5:3d5d2c393e654574
	{"%v", byteFormatterSlice, "[X X X X X]"},
	{"%s", byteFormatterSlice, "hello"},
	{"%q", byteFormatterSlice, "\"hello\""},
	{"%x", byteFormatterSlice, "68656c6c6f"},
	{"%X", byteFormatterSlice, "68656C6C6F"},
	// ä¸‹ä¸€ä¸ªæƒ…å†µçœ‹èµ·æ¥æ˜¯é”™è¯¯çš„ï¼Œä½†æ–‡æ¡£è¯´æ˜Formatteråœ¨è¿™é‡Œä¼šå–èƒœã€‚. md5:fcc2426006db2b69
	{"%#v", byteFormatterSlice, "[]fmt_test.byteFormatter{X, X, X, X, X}"},

	// pp.WriteString
	{"%s", writeStringFormatter(""), "******"},
	{"%s", writeStringFormatter("xyz"), "***xyz***"},
	{"%s", writeStringFormatter("âŒ˜/âŒ˜"), "***âŒ˜/âŒ˜***"},

	// åœ¨Go 1.5ä¸­ç‰¹åˆ«å¤„ç†äº†reflect.Valueï¼Œä½¿å¾—å¯ä»¥
	// è§‚å¯Ÿéå¯¼å‡ºå­—æ®µçš„å†…éƒ¨ï¼ˆè¿™äº›å­—æ®µæ— æ³•é€šè¿‡Interface()è®¿é—®ï¼‰ã€‚
	// é—®é¢˜Issue 8965ã€‚
	// md5:f53b74d57ef9e0e9
	{"%v", reflect.ValueOf(A{}).Field(0).String(), "<int Value>"}, // ç­‰åŒäºæ—§çš„æ–¹æ³•ã€‚. md5:b288249e76f1a71f
	{"%v", reflect.ValueOf(A{}).Field(0), "0"},                    // Sees inside the field.

	// è¿™äº›åŠ¨è¯ä¹Ÿä½œç”¨äºæå–çš„å€¼ã€‚. md5:591df534d9964828
	{"%s", reflect.ValueOf("hello"), "hello"},
	{"%q", reflect.ValueOf("hello"), `"hello"`},
	{"%#04x", reflect.ValueOf(256), "0x0100"},

	// æ— æ•ˆçš„åå°„.Valueä¸ä¼šå¯¼è‡´å´©æºƒã€‚. md5:47b7e95a4a28f4ce
	{"%v", reflect.Value{}, "<invalid reflect.Value>"},
	{"%v", &reflect.Value{}, "<invalid Value>"},
	{"%v", SI{reflect.Value{}}, "{<invalid Value>}"},

	// æµ‹è¯•æ£€æŸ¥ä¸æ”¯æŒçš„åŠ¨è¯æ˜¯å¦ä¼šç”Ÿæˆé”™è¯¯ä¿¡æ¯ã€‚. md5:3fd253b1e4347a90
	{"%â˜ ", nil, "%!â˜ (<nil>)"},
	{"%â˜ ", any(nil), "%!â˜ (<nil>)"},
	{"%â˜ ", int(0), "%!â˜ (int=0)"},
	{"%â˜ ", uint(0), "%!â˜ (uint=0)"},
	{"%â˜ ", []byte{0, 1}, "[%!â˜ (uint8=0) %!â˜ (uint8=1)]"},
	{"%â˜ ", []uint8{0, 1}, "[%!â˜ (uint8=0) %!â˜ (uint8=1)]"},
	{"%â˜ ", [1]byte{0}, "[%!â˜ (uint8=0)]"},
	{"%â˜ ", [1]uint8{0}, "[%!â˜ (uint8=0)]"},
	{"%â˜ ", "hello", "%!â˜ (string=hello)"},
	{"%â˜ ", 1.2345678, "%!â˜ (float64=1.2345678)"},
	{"%â˜ ", float32(1.2345678), "%!â˜ (float32=1.2345678)"},
	{"%â˜ ", 1.2345678 + 1.2345678i, "%!â˜ (complex128=(1.2345678+1.2345678i))"},
	{"%â˜ ", complex64(1.2345678 + 1.2345678i), "%!â˜ (complex64=(1.2345678+1.2345678i))"},
	{"%â˜ ", &intVar, "%!â˜ (*int=0xPTR)"},
	{"%â˜ ", make(chan int), "%!â˜ (chan int=0xPTR)"},
	{"%â˜ ", func() {}, "%!â˜ (func()=0xPTR)"},
	{"%â˜ ", reflect.ValueOf(renamedInt(0)), "%!â˜ (fmt_test.renamedInt=0)"},
	{"%â˜ ", SI{renamedInt(0)}, "{%!â˜ (fmt_test.renamedInt=0)}"},
	{"%â˜ ", &[]any{I(1), G(2)}, "&[%!â˜ (fmt_test.I=1) %!â˜ (fmt_test.G=2)]"},
	{"%â˜ ", SI{&[]any{I(1), G(2)}}, "{%!â˜ (*[]interface {}=&[1 2])}"},
	{"%â˜ ", reflect.Value{}, "<invalid reflect.Value>"},
	{"%â˜ ", map[float64]int{NaN: 1}, "map[%!â˜ (float64=NaN):%!â˜ (int=1)]"},
}

// zeroFill ç”ŸæˆæŒ‡å®šå®½åº¦çš„é›¶å¡«å……å­—ç¬¦ä¸²ã€‚åœ¨è®¡ç®—å®½åº¦æ—¶ä¼šè¡¥å¿åç¼€ï¼ˆè€Œä¸æ˜¯å‰ç¼€ï¼‰çš„é•¿åº¦ã€‚
// md5:166c1bba0c8b0fa3
func zeroFill(prefix string, width int, suffix string) string {
	return prefix + strings.Repeat("0", width-len(suffix)) + suffix
}

func TestSprintf(t *testing.T) {
	for _, tt := range fmtTests {
		s := Sprintf(tt.fmt, tt.val)
		i := strings.Index(tt.out, "PTR")
		if i >= 0 && i < len(s) {
			var pattern, chars string
			switch {
			case strings.HasPrefix(tt.out[i:], "PTR_b"):
				pattern = "PTR_b"
				chars = "01"
			case strings.HasPrefix(tt.out[i:], "PTR_o"):
				pattern = "PTR_o"
				chars = "01234567"
			case strings.HasPrefix(tt.out[i:], "PTR_d"):
				pattern = "PTR_d"
				chars = "0123456789"
			case strings.HasPrefix(tt.out[i:], "PTR_x"):
				pattern = "PTR_x"
				chars = "0123456789abcdef"
			case strings.HasPrefix(tt.out[i:], "PTR_X"):
				pattern = "PTR_X"
				chars = "0123456789ABCDEF"
			default:
				pattern = "PTR"
				chars = "0123456789abcdefABCDEF"
			}
			p := s[:i] + pattern
			for j := i; j < len(s); j++ {
				if !strings.ContainsRune(chars, rune(s[j])) {
					p += s[j:]
					break
				}
			}
			s = p
		}
		if s != tt.out {
			if _, ok := tt.val.(string); ok {
				// ä¸è¦å¯¹å·²ç»å¼•ç”¨çš„å­—ç¬¦ä¸²è¿›è¡ŒäºŒæ¬¡å¼•ç”¨ã€‚
				// é˜…è¯»é”™è¯¯ä¿¡æ¯ä¼šå¾ˆå›°æƒ‘ã€‚
				// md5:ba8c726918db0e02
				t.Errorf("Sprintf(%q, %q) = <%s> want <%s>", tt.fmt, tt.val, s, tt.out)
			} else {
				t.Errorf("Sprintf(%q, %v) = %q want %q", tt.fmt, tt.val, s, tt.out)
			}
		}
	}
}

// TestComplexFormatting æ£€æŸ¥ä¸€ä¸ªå¤æ‚çš„æ ¼å¼åŒ–ç»“æœæ˜¯å¦å§‹ç»ˆä¸æ‰‹åŠ¨ä½¿ç”¨ä¸¤ä¸ªå•ä¾‹æ‰“å°å¾—åˆ°çš„ç»“æœç›¸åŒã€‚
// md5:d4dd5d418eb8bbcb
func TestComplexFormatting(t *testing.T) {
	var yesNo = []bool{true, false}
	var values = []float64{1, 0, -1, posInf, negInf, NaN}
	for _, plus := range yesNo {
		for _, zero := range yesNo {
			for _, space := range yesNo {
				for _, char := range "fFeEgG" {
					realFmt := "%"
					if zero {
						realFmt += "0"
					}
					if space {
						realFmt += " "
					}
					if plus {
						realFmt += "+"
					}
					realFmt += "10.2"
					realFmt += string(char)
					// è™šéƒ¨æ€»æ˜¯æœ‰ç¬¦å·çš„ï¼Œå› æ­¤å¼ºåˆ¶ä½¿ç”¨+å¹¶å¿½ç•¥ç©ºæ ¼ã€‚. md5:3478885701ff07cb
					imagFmt := "%"
					if zero {
						imagFmt += "0"
					}
					imagFmt += "+"
					imagFmt += "10.2"
					imagFmt += string(char)
					for _, realValue := range values {
						for _, imagValue := range values {
							one := Sprintf(realFmt, complex(realValue, imagValue))
							two := Sprintf("("+realFmt+imagFmt+"i)", realValue, imagValue)
							if one != two {
								t.Error(f, one, two)
							}
						}
					}
				}
			}
		}
	}
}

type SE []any // ç©ºçš„åˆ‡ç‰‡ï¼›è¡¨ç¤ºä¸Šçš„ç´§å‡‘æ€§ã€‚. md5:0c6510b82e66fcbc

var reorderTests = []struct {
	fmt string
	val SE
	out string
}{
	{"%[1]d", SE{1}, "1"},
	{"%[2]d", SE{2, 1}, "1"},
	{"%[2]d %[1]d", SE{1, 2}, "2 1"},
	{"%[2]*[1]d", SE{2, 5}, "    2"},
	{"%6.2f", SE{12.0}, " 12.00"}, // ä¸‹ä¸€è¡Œçš„æ˜¾å¼ç‰ˆæœ¬ã€‚. md5:6ac52b71311e0e5f
	{"%[3]*.[2]*[1]f", SE{12.0, 2, 6}, " 12.00"},
	{"%[1]*.[2]*[3]f", SE{6, 2, 12.0}, " 12.00"},
	{"%10f", SE{12.0}, " 12.000000"},
	{"%[1]*[3]f", SE{10, 99, 12.0}, " 12.000000"},
	{"%.6f", SE{12.0}, "12.000000"}, // ä¸‹ä¸€è¡Œçš„æ˜¾å¼ç‰ˆæœ¬ã€‚. md5:6ac52b71311e0e5f
	{"%.[1]*[3]f", SE{6, 99, 12.0}, "12.000000"},
	{"%6.f", SE{12.0}, "    12"}, //  // ä¸‹ä¸€è¡Œçš„æ˜ç¡®ç‰ˆæœ¬ï¼›ç©ºç²¾åº¦æ„å‘³ç€é›¶ã€‚. md5:beec2c5c5bdb243b
	{"%[1]*.[3]f", SE{6, 3, 12.0}, "    12"},
	// ä¸€ä¸ªå®é™…çš„åº”ç”¨ï¼æ‰“å°ä¸¤æ¬¡ç›¸åŒçš„å‚æ•°ã€‚. md5:50c392eca0f17937
	{"%d %d %d %#[1]o %#o %#o", SE{11, 12, 13}, "11 12 13 013 014 015"},

	// Erroneous cases.
	{"%[d", SE{2, 1}, "%!d(BADINDEX)"},
	{"%]d", SE{2, 1}, "%!](int=2)d%!(EXTRA int=1)"},
	{"%[]d", SE{2, 1}, "%!d(BADINDEX)"},
	{"%[-3]d", SE{2, 1}, "%!d(BADINDEX)"},
	{"%[99]d", SE{2, 1}, "%!d(BADINDEX)"},
	{"%[3]", SE{2, 1}, "%!(NOVERB)"},
	{"%[1].2d", SE{5, 6}, "%!d(BADINDEX)"},
	{"%[1]2d", SE{2, 1}, "%!d(BADINDEX)"},
	{"%3.[2]d", SE{7}, "%!d(BADINDEX)"},
	{"%.[2]d", SE{7}, "%!d(BADINDEX)"},
	{"%d %d %d %#[1]o %#o %#o %#o", SE{11, 12, 13}, "11 12 13 013 014 015 %!o(MISSING)"},
	{"%[5]d %[2]d %d", SE{1, 2, 3}, "%!d(BADINDEX) 2 3"},
	{"%d %[3]d %d", SE{1, 2}, "1 %!d(BADINDEX) 2"}, // é”™è¯¯çš„ç´¢å¼•ä¸ä¼šå½±å“åºåˆ—ã€‚. md5:2a002c80f25a97e9
	{"%.[]", SE{}, "%!](BADINDEX)"},                // Issue 10675
	{"%.-3d", SE{42}, "%!-(int=42)3d"},             // TODOï¼šè¿™ä¸ªè®¾ç½®åº”è¯¥è¿”å›æ›´å¥½çš„é”™è¯¯æ¶ˆæ¯å—ï¼Ÿ. md5:83eec8be12b4cb4b
	{"%2147483648d", SE{42}, "%!(NOVERB)%!(EXTRA int=42)"},
	{"%-2147483648d", SE{42}, "%!(NOVERB)%!(EXTRA int=42)"},
	{"%.2147483648d", SE{42}, "%!(NOVERB)%!(EXTRA int=42)"},
}

func TestReorder(t *testing.T) {
	for _, tt := range reorderTests {
		s := Sprintf(tt.fmt, tt.val...)
		if s != tt.out {
			t.Errorf("Sprintf(%q, %v) = <%s> want <%s>", tt.fmt, tt.val, s, tt.out)
		} else {
		}
	}
}

func BenchmarkSprintfPadding(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%16f", 1.0)
		}
	})
}

func BenchmarkSprintfEmpty(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("")
		}
	})
}

func BenchmarkSprintfString(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%s", "hello")
		}
	})
}

func BenchmarkSprintfTruncateString(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%.3s", "æ—¥æœ¬èªæ—¥æœ¬èªæ—¥æœ¬èªæ—¥æœ¬èª")
		}
	})
}

func BenchmarkSprintfTruncateBytes(b *testing.B) {
	var bytes any = []byte("æ—¥æœ¬èªæ—¥æœ¬èªæ—¥æœ¬èªæ—¥æœ¬èª")
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%.3s", bytes)
		}
	})
}

func BenchmarkSprintfSlowParsingPath(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%.v", nil)
		}
	})
}

func BenchmarkSprintfQuoteString(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%q", "æ—¥æœ¬èªæ—¥æœ¬èªæ—¥æœ¬èª")
		}
	})
}

func BenchmarkSprintfInt(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%d", 5)
		}
	})
}

func BenchmarkSprintfIntInt(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%d %d", 5, 6)
		}
	})
}

func BenchmarkSprintfPrefixedInt(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("This is some meaningless prefix text that needs to be scanned %d", 6)
		}
	})
}

func BenchmarkSprintfFloat(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%g", 5.23184)
		}
	})
}

func BenchmarkSprintfComplex(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%f", 5.23184+5.23184i)
		}
	})
}

func BenchmarkSprintfBoolean(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%t", true)
		}
	})
}

func BenchmarkSprintfHexString(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("% #x", "0123456789abcdef")
		}
	})
}

func BenchmarkSprintfHexBytes(b *testing.B) {
	data := []byte("0123456789abcdef")
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("% #x", data)
		}
	})
}

func BenchmarkSprintfBytes(b *testing.B) {
	data := []byte("0123456789abcdef")
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%v", data)
		}
	})
}

func BenchmarkSprintfStringer(b *testing.B) {
	stringer := I(12345)
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%v", stringer)
		}
	})
}

func BenchmarkSprintfStructure(b *testing.B) {
	s := &[]any{SI{12345}, map[int]string{0: "hello"}}
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_ = Sprintf("%#v", s)
		}
	})
}

func BenchmarkManyArgs(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		var buf bytes.Buffer
		for pb.Next() {
			buf.Reset()
			Fprintf(&buf, "%2d/%2d/%2d %d:%d:%d %s %s\n", 3, 4, 5, 11, 12, 13, "hello", "world")
		}
	})
}

func BenchmarkFprintInt(b *testing.B) {
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		Fprint(&buf, 123456)
	}
}

func BenchmarkFprintfBytes(b *testing.B) {
	data := []byte(string("0123456789"))
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		Fprintf(&buf, "%s", data)
	}
}

func BenchmarkFprintIntNoAlloc(b *testing.B) {
	var x any = 123456
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		Fprint(&buf, x)
	}
}

var mallocBuf bytes.Buffer
var mallocPointer *int // A pointer so we know the interface value won't allocate.

var mallocTest = []struct {
	count int
	desc  string
	fn    func()
}{
	{0, `Sprintf("")`, func() { _ = Sprintf("") }},
	{1, `Sprintf("xxx")`, func() { _ = Sprintf("xxx") }},
	{0, `Sprintf("%x")`, func() { _ = Sprintf("%x", 7) }},
	{1, `Sprintf("%x")`, func() { _ = Sprintf("%x", 1<<16) }},
	{3, `Sprintf("%80000s")`, func() { _ = Sprintf("%80000s", "hello") }}, // large buffer (>64KB)
	{1, `Sprintf("%s")`, func() { _ = Sprintf("%s", "hello") }},
	{1, `Sprintf("%x %x")`, func() { _ = Sprintf("%x %x", 7, 112) }},
	{1, `Sprintf("%g")`, func() { _ = Sprintf("%g", float32(3.14159)) }},
	{0, `Fprintf(buf, "%s")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, "%s", "hello") }},
	{0, `Fprintf(buf, "%x")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, "%x", 7) }},
	{0, `Fprintf(buf, "%x")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, "%x", 1<<16) }},
	{2, `Fprintf(buf, "%80000s")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, "%80000s", "hello") }}, // large buffer (>64KB)
	// å¦‚æœæ¥å£å€¼ä¸éœ€è¦åˆ†é…ï¼Œé‚£ä¹ˆæŠ˜æ—§åˆ†é…å¼€é”€åº”è¯¥æ˜¯é›¶ã€‚. md5:3b4c5ae37bedf5d7
	{0, `Fprintf(buf, "%x %x %x")`, func() {
		mallocBuf.Reset()
		Fprintf(&mallocBuf, "%x %x %x", mallocPointer, mallocPointer, mallocPointer)
	}},
}

var _ bytes.Buffer

func TestCountMallocs(t *testing.T) {
	switch {
	case testing.Short():
		t.Skip("skipping malloc count in short mode")
	case runtime.GOMAXPROCS(0) > 1:
		t.Skip("skipping; GOMAXPROCS>1")
	case race.Enabled:
		t.Skip("skipping malloc count under race detector")
	}
	for _, mt := range mallocTest {
		mallocs := testing.AllocsPerRun(100, mt.fn)
		if got, max := mallocs, float64(mt.count); got > max {
			t.Errorf("%s: got %v allocs, want <=%v", mt.desc, got, max)
		}
	}
}

type flagPrinter struct{}

func (flagPrinter) Format(f fmt2.State, c rune) {
	s := "%"
	for i := 0; i < 128; i++ {
		if f.Flag(i) {
			s += string(rune(i))
		}
	}
	if w, ok := f.Width(); ok {
		s += Sprintf("%d", w)
	}
	if p, ok := f.Precision(); ok {
		s += Sprintf(".%d", p)
	}
	s += string(c)
	io.WriteString(f, "["+s+"]")
}

var flagtests = []struct {
	in  string
	out string
}{
	{"%a", "[%a]"},
	{"%-a", "[%-a]"},
	{"%+a", "[%+a]"},
	{"%#a", "[%#a]"},
	{"% a", "[% a]"},
	{"%0a", "[%0a]"},
	{"%1.2a", "[%1.2a]"},
	{"%-1.2a", "[%-1.2a]"},
	{"%+1.2a", "[%+1.2a]"},
	{"%-+1.2a", "[%+-1.2a]"},
	{"%-+1.2abc", "[%+-1.2a]bc"},
	{"%-1.2abc", "[%-1.2a]bc"},
}

func TestFlagParser(t *testing.T) {
	var flagprinter flagPrinter
	for _, tt := range flagtests {
		s := Sprintf(tt.in, &flagprinter)
		if s != tt.out {
			t.Errorf("Sprintf(%q, &flagprinter) => %q, want %q", tt.in, s, tt.out)
		}
	}
}

func TestStructPrinter(t *testing.T) {
	type T struct {
		a string
		b string
		c int
	}
	var s T
	s.a = "abc"
	s.b = "def"
	s.c = 123
	var tests = []struct {
		fmt string
		out string
	}{
		{"%v", "{abc def 123}"},
		{"%+v", "{a:abc b:def c:123}"},
		{"%#v", `fmt_test.T{a:"abc", b:"def", c:123}`},
	}
	for _, tt := range tests {
		out := Sprintf(tt.fmt, s)
		if out != tt.out {
			t.Errorf("Sprintf(%q, s) = %#q, want %#q", tt.fmt, out, tt.out)
		}
		// åŒæ ·æ˜¯è¿™ä¸ªï¼Œä½†æ˜¯ä½¿ç”¨äº†æŒ‡é’ˆã€‚. md5:b52f4a5b228ff7de
		out = Sprintf(tt.fmt, &s)
		if out != "&"+tt.out {
			t.Errorf("Sprintf(%q, &s) = %#q, want %#q", tt.fmt, out, "&"+tt.out)
		}
	}
}

func TestSlicePrinter(t *testing.T) {
	slice := []int{}
	s := Sprint(slice)
	if s != "[]" {
		t.Errorf("empty slice printed as %q not %q", s, "[]")
	}
	slice = []int{1, 2, 3}
	s = Sprint(slice)
	if s != "[1 2 3]" {
		t.Errorf("slice: got %q expected %q", s, "[1 2 3]")
	}
	s = Sprint(&slice)
	if s != "&[1 2 3]" {
		t.Errorf("&slice: got %q expected %q", s, "&[1 2 3]")
	}
}

// presentInMap æ£€æŸ¥æ˜ å°„ä¸­æ˜¯å¦å­˜åœ¨æŒ‡å®šçš„å­å­—ç¬¦ä¸²ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸ä¾èµ–äºæ‰“å°é¡ºåºã€‚
// md5:793ea6a69c121ef4
func presentInMap(s string, a []string, t *testing.T) {
	for i := 0; i < len(a); i++ {
		loc := strings.Index(s, a[i])
		if loc < 0 {
			t.Errorf("map print: expected to find %q in %q", a[i], s)
		}
		// ç¡®ä¿åŒ¹é…åœ¨è¿™é‡Œç»“æŸ. md5:51f55c798e9f7848
		loc += len(a[i])
		if loc >= len(s) || (s[loc] != ' ' && s[loc] != ']') {
			t.Errorf("map print: %q not properly terminated in %q", a[i], s)
		}
	}
}

func TestMapPrinter(t *testing.T) {
	m0 := make(map[int]string)
	s := Sprint(m0)
	if s != "map[]" {
		t.Errorf("empty map printed as %q not %q", s, "map[]")
	}
	m1 := map[int]string{1: "one", 2: "two", 3: "three"}
	a := []string{"1:one", "2:two", "3:three"}
	presentInMap(Sprintf("%v", m1), a, t)
	presentInMap(Sprint(m1), a, t)
	// åœ°å€ç¬¦æŒ‡å‘çš„æ˜ å°„æ‰“å°ç›¸åŒï¼Œä½†å¸¦æœ‰åˆå§‹çš„&ã€‚. md5:fe7b293d22d96ece
	if !strings.HasPrefix(Sprint(&m1), "&") {
		t.Errorf("no initial & for address of map")
	}
	presentInMap(Sprintf("%v", &m1), a, t)
	presentInMap(Sprint(&m1), a, t)
}

func TestEmptyMap(t *testing.T) {
	const emptyMapStr = "map[]"
	var m map[string]int
	s := Sprint(m)
	if s != emptyMapStr {
		t.Errorf("nil map printed as %q not %q", s, emptyMapStr)
	}
	m = make(map[string]int)
	s = Sprint(m)
	if s != emptyMapStr {
		t.Errorf("empty map printed as %q not %q", s, emptyMapStr)
	}
}

// TestBlank æ£€æŸ¥ Sprintï¼ˆä»¥åŠå› æ­¤ Printã€Fprintï¼‰æ˜¯å¦åœ¨æ­£ç¡®çš„ä½ç½®æ’å…¥ç©ºæ ¼ï¼Œ
// ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ä¸¤ä¸ªéƒ½ä¸æ˜¯å­—ç¬¦ä¸²çš„å‚æ•°å¯¹ä¹‹é—´æ’å…¥ç©ºæ ¼ã€‚
// md5:53c45912a74541c9
func TestBlank(t *testing.T) {
	got := Sprint("<", 1, ">:", 1, 2, 3, "!")
	expect := "<1>:1 2 3!"
	if got != expect {
		t.Errorf("got %q expected %q", got, expect)
	}
}

// TestBlankln æ£€æŸ¥ Sprintlnï¼ˆå› æ­¤ä¹Ÿæ£€æŸ¥ Println å’Œ Fprintlnï¼‰æ˜¯å¦åœ¨æ­£ç¡®çš„ä½ç½®æ”¾ç½®ç©ºæ ¼ï¼Œå³åœ¨æ‰€æœ‰å‚æ•°å¯¹ä¹‹é—´ã€‚
// md5:808febd555ac992a
func TestBlankln(t *testing.T) {
	got := Sprintln("<", 1, ">:", 1, 2, 3, "!")
	expect := "< 1 >: 1 2 3 !\n"
	if got != expect {
		t.Errorf("got %q expected %q", got, expect)
	}
}

// TestFormatterPrintln æ£€æŸ¥ Formatter æ˜¯å¦ä¸ Sprintã€Sprintlnã€Sprintf å…¼å®¹ã€‚. md5:317c04475c2e31e1
func TestFormatterPrintln(t *testing.T) {
	f := F(1)
	expect := "<v=F(1)>\n"
	s := Sprint(f, "\n")
	if s != expect {
		t.Errorf("Sprint wrong with Formatter: expected %q got %q", expect, s)
	}
	s = Sprintln(f)
	if s != expect {
		t.Errorf("Sprintln wrong with Formatter: expected %q got %q", expect, s)
	}
	s = Sprintf("%v\n", f)
	if s != expect {
		t.Errorf("Sprintf wrong with Formatter: expected %q got %q", expect, s)
	}
}

func args(a ...any) []any { return a }

var startests = []struct {
	fmt string
	in  []any
	out string
}{
	{"%*d", args(4, 42), "  42"},
	{"%-*d", args(4, 42), "42  "},
	{"%*d", args(-4, 42), "42  "},
	{"%-*d", args(-4, 42), "42  "},
	{"%.*d", args(4, 42), "0042"},
	{"%*.*d", args(8, 4, 42), "    0042"},
	{"%0*d", args(4, 42), "0042"},
	// ä¸€äº›éæ•´å‹çš„å®½åº¦ã€‚ (é—®é¢˜ 10732)ã€‚. md5:c7b71c0c4570660b
	{"%0*d", args(uint(4), 42), "0042"},
	{"%0*d", args(uint64(4), 42), "0042"},
	{"%0*d", args('\x04', 42), "0042"},
	{"%0*d", args(uintptr(4), 42), "0042"},

	// erroneous
	{"%*d", args(nil, 42), "%!(BADWIDTH)42"},
	{"%*d", args(int(1e7), 42), "%!(BADWIDTH)42"},
	{"%*d", args(int(-1e7), 42), "%!(BADWIDTH)42"},
	{"%.*d", args(nil, 42), "%!(BADPREC)42"},
	{"%.*d", args(-1, 42), "%!(BADPREC)42"},
	{"%.*d", args(int(1e7), 42), "%!(BADPREC)42"},
	{"%.*d", args(uint(1e7), 42), "%!(BADPREC)42"},
	{"%.*d", args(uint64(1<<63), 42), "%!(BADPREC)42"},   // Huge negative (-inf).
	{"%.*d", args(uint64(1<<64-1), 42), "%!(BADPREC)42"}, // Small negative (-1).
	{"%*d", args(5, "foo"), "%!d(string=  foo)"},
	{"%*% %d", args(20, 5), "% 5"},
	{"%*", args(4), "%!(NOVERB)"},
}

func TestWidthAndPrecision(t *testing.T) {
	for i, tt := range startests {
		s := Sprintf(tt.fmt, tt.in...)
		if s != tt.out {
			t.Errorf("#%d: %q: got %q expected %q", i, tt.fmt, s, tt.out)
		}
	}
}

// PanicS æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå…¶åœ¨ String æ–¹æ³•ä¸­å¼•å‘ææ…Œã€‚. md5:f9f51e76f8663022
type PanicS struct {
	message any
}

// Value receiver.
func (p PanicS) String() string {
	panic(p.message)
}

// PanicGo æ˜¯ä¸€ç§ç±»å‹ï¼Œå…¶åœ¨ GoString æ–¹æ³•ä¸­ä¼šå¼•å‘ panicã€‚. md5:325e8a82677affa7
type PanicGo struct {
	message any
}

// Value receiver.
func (p PanicGo) GoString() string {
	panic(p.message)
}

// PanicF æ˜¯ä¸€ä¸ªåœ¨ Format ä¸­å¼•å‘ panic çš„ç±»å‹ã€‚. md5:75281a7f645c4884
type PanicF struct {
	message any
}

// Value receiver.
func (p PanicF) Format(f fmt2.State, c rune) {
	panic(p.message)
}

var panictests = []struct {
	fmt string
	in  any
	out string
}{
	// String
	{"%s", (*PanicS)(nil), "<nil>"}, // å¯¹ç©ºæŒ‡é’ˆçš„ç‰¹æ®Šå¤„ç†. md5:3aa8c1e6fd615479
	{"%s", PanicS{io.ErrUnexpectedEOF}, "%!s(PANIC=String method: unexpected EOF)"},
	{"%s", PanicS{3}, "%!s(PANIC=String method: 3)"},
	// GoString
	{"%#v", (*PanicGo)(nil), "<nil>"}, // å¯¹ç©ºæŒ‡é’ˆçš„ç‰¹æ®Šå¤„ç†. md5:3aa8c1e6fd615479
	{"%#v", PanicGo{io.ErrUnexpectedEOF}, "%!v(PANIC=GoString method: unexpected EOF)"},
	{"%#v", PanicGo{3}, "%!v(PANIC=GoString method: 3)"},
	// Issue 18282ã€‚catchPanic ä¸åº”è¯¥æ°¸ä¹…æ€§åœ°æ¸…é™¤ fmtFlagsã€‚. md5:58923a2a12714a31
	{"%#v", []any{PanicGo{3}, PanicGo{3}}, "[]interface {}{%!v(PANIC=GoString method: 3), %!v(PANIC=GoString method: 3)}"},
	// Format
	{"%s", (*PanicF)(nil), "<nil>"}, // å¯¹ç©ºæŒ‡é’ˆçš„ç‰¹æ®Šå¤„ç†. md5:3aa8c1e6fd615479
	{"%s", PanicF{io.ErrUnexpectedEOF}, "%!s(PANIC=Format method: unexpected EOF)"},
	{"%s", PanicF{3}, "%!s(PANIC=Format method: 3)"},
}

func TestPanics(t *testing.T) {
	for i, tt := range panictests {
		s := Sprintf(tt.fmt, tt.in)
		if s != tt.out {
			t.Errorf("%d: %q: got %q expected %q", i, tt.fmt, s, tt.out)
		}
	}
}

// recurCount æµ‹è¯•é”™è¯¯çš„ String å‡½æ•°ä¸ä¼šå¯¼è‡´è‡´å‘½é€’å½’ã€‚. md5:0f835493bc816db5
var recurCount = 0

type Recur struct {
	i      int
	failed *bool
}

func (r *Recur) String() string {
	if recurCount++; recurCount > 10 {
		*r.failed = true
		return "FAIL"
	}
	// è¿™å°†è°ƒç”¨badVerbã€‚åœ¨ä¿®å¤ä¹‹å‰ï¼Œè¿™ä¼šå¯¼è‡´æˆ‘ä»¬é€’å½’è¿›å…¥æ­¤ä¾‹ç¨‹æ¥æ‰“å°%!p(value)ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬åœ¨å‘ç”Ÿé”™è¯¯æ—¶ä¸ä¼šè°ƒç”¨ç”¨æˆ·çš„å‡½æ•°ã€‚
	// md5:9a0c04ff32b63d48
	return Sprintf("recur@%p value: %d", r, r.i)
}

func TestBadVerbRecursion(t *testing.T) {
	failed := false
	r := &Recur{3, &failed}
	_ = Sprintf("recur@%p value: %d\n", &r, r.i)
	if failed {
		t.Error("fail with pointer")
	}
	failed = false
	r = &Recur{4, &failed}
	_ = Sprintf("recur@%p, value: %d\n", r, r.i)
	if failed {
		t.Error("fail with value")
	}
}

// è¿™ä¸ªæµ‹è¯•äº†å†…éƒ¨çš„isSpaceå‡½æ•°ã€‚
// isSpace æ˜¯åœ¨ export_test.go ä¸­å®šä¹‰çš„ã€‚
// md5:6f01a8f9bb93e8c0
//	for i := rune(0); i <= unicode.MaxRune; i++ {
//		if IsSpace(i) != unicode.IsSpace(i) {
//			t.Errorf("isSpace(%U) = %v, want %v", i, IsSpace(i), unicode.IsSpace(i))
//		}
//	}
//}

func hideFromVet(s string) string { return s }

func TestNilDoesNotBecomeTyped(t *testing.T) {
	type A struct{}
	type B struct{}
	var a *A = nil
	var b B = B{}
	got := Sprintf(hideFromVet("%s %s %s %s %s"), nil, a, nil, b, nil)
	const expect = "%!s(<nil>) %!s(*fmt_test.A=<nil>) %!s(<nil>) {} %!s(<nil>)"
	if got != expect {
		t.Errorf("expected:\n\t%q\ngot:\n\t%q", expect, got)
	}
}

var formatterFlagTests = []struct {
	in  string
	val any
	out string
}{
	// ä½¿ç”¨ï¼ˆè¢«fmtåŒ…æœªä½¿ç”¨çš„ï¼‰'a' ä¿®é¥°ç¬¦çš„æ ‡é‡å€¼ã€‚. md5:fb9ef85626d44528
	{"%a", flagPrinter{}, "[%a]"},
	{"%-a", flagPrinter{}, "[%-a]"},
	{"%+a", flagPrinter{}, "[%+a]"},
	{"%#a", flagPrinter{}, "[%#a]"},
	{"% a", flagPrinter{}, "[% a]"},
	{"%0a", flagPrinter{}, "[%0a]"},
	{"%1.2a", flagPrinter{}, "[%1.2a]"},
	{"%-1.2a", flagPrinter{}, "[%-1.2a]"},
	{"%+1.2a", flagPrinter{}, "[%+1.2a]"},
	{"%-+1.2a", flagPrinter{}, "[%+-1.2a]"},
	{"%-+1.2abc", flagPrinter{}, "[%+-1.2a]bc"},
	{"%-1.2abc", flagPrinter{}, "[%-1.2a]bc"},

	// ä½¿ç”¨ 'a' åŠ¨è¯ç»„åˆå€¼. md5:53eb4e452bf8ac9e
	{"%a", [1]flagPrinter{}, "[[%a]]"},
	{"%-a", [1]flagPrinter{}, "[[%-a]]"},
	{"%+a", [1]flagPrinter{}, "[[%+a]]"},
	{"%#a", [1]flagPrinter{}, "[[%#a]]"},
	{"% a", [1]flagPrinter{}, "[[% a]]"},
	{"%0a", [1]flagPrinter{}, "[[%0a]]"},
	{"%1.2a", [1]flagPrinter{}, "[[%1.2a]]"},
	{"%-1.2a", [1]flagPrinter{}, "[[%-1.2a]]"},
	{"%+1.2a", [1]flagPrinter{}, "[[%+1.2a]]"},
	{"%-+1.2a", [1]flagPrinter{}, "[[%+-1.2a]]"},
	{"%-+1.2abc", [1]flagPrinter{}, "[[%+-1.2a]]bc"},
	{"%-1.2abc", [1]flagPrinter{}, "[[%-1.2a]]bc"},

	// ä½¿ç”¨'v'åŠ¨è¯çš„ç®€å•å€¼. md5:55fa2b55a52125f3
	{"%v", flagPrinter{}, "[%v]"},
	{"%-v", flagPrinter{}, "[%-v]"},
	{"%+v", flagPrinter{}, "[%+v]"},
	{"%#v", flagPrinter{}, "[%#v]"},
	{"% v", flagPrinter{}, "[% v]"},
	{"%0v", flagPrinter{}, "[%0v]"},
	{"%1.2v", flagPrinter{}, "[%1.2v]"},
	{"%-1.2v", flagPrinter{}, "[%-1.2v]"},
	{"%+1.2v", flagPrinter{}, "[%+1.2v]"},
	{"%-+1.2v", flagPrinter{}, "[%+-1.2v]"},
	{"%-+1.2vbc", flagPrinter{}, "[%+-1.2v]bc"},
	{"%-1.2vbc", flagPrinter{}, "[%-1.2v]bc"},

	// ä½¿ç”¨'v'åŠ¨è¯ç»„åˆå€¼ã€‚. md5:5c3ded605cfc3db8
	{"%v", [1]flagPrinter{}, "[[%v]]"},
	{"%-v", [1]flagPrinter{}, "[[%-v]]"},
	{"%+v", [1]flagPrinter{}, "[[%+v]]"},
	{"%#v", [1]flagPrinter{}, "[1]fmt_test.flagPrinter{[%#v]}"},
	{"% v", [1]flagPrinter{}, "[[% v]]"},
	{"%0v", [1]flagPrinter{}, "[[%0v]]"},
	{"%1.2v", [1]flagPrinter{}, "[[%1.2v]]"},
	{"%-1.2v", [1]flagPrinter{}, "[[%-1.2v]]"},
	{"%+1.2v", [1]flagPrinter{}, "[[%+1.2v]]"},
	{"%-+1.2v", [1]flagPrinter{}, "[[%+-1.2v]]"},
	{"%-+1.2vbc", [1]flagPrinter{}, "[[%+-1.2v]]bc"},
	{"%-1.2vbc", [1]flagPrinter{}, "[[%-1.2v]]bc"},
}

func TestFormatterFlags(t *testing.T) {
	for _, tt := range formatterFlagTests {
		s := Sprintf(tt.in, tt.val)
		if s != tt.out {
			t.Errorf("Sprintf(%q, %T) = %q, want %q", tt.in, tt.val, s, tt.out)
		}
	}
}

//func TestParsenum(t *testing.T) {
//	testCases := []struct {
//		s          string
//		start, end int
//		num        int
//		isnum      bool
//		newi       int
//	}{
//		{"a123", 0, 4, 0, false, 0},
//		{"1234", 1, 1, 0, false, 1},
//		{"123a", 0, 4, 123, true, 3},
//		{"12a3", 0, 4, 12, true, 2},
//		{"1234", 0, 4, 1234, true, 4},
//		{"1a234", 1, 3, 0, false, 1},
//	}
//	for _, tt := range testCases {
//		num, isnum, newi := Parsenum(tt.s, tt.start, tt.end)
//		if num != tt.num || isnum != tt.isnum || newi != tt.newi {
//			t.Errorf("parsenum(%q, %d, %d) = %d, %v, %d, want %d, %v, %d", tt.s, tt.start, tt.end, num, isnum, newi, tt.num, tt.isnum, tt.newi)
//		}
//	}
//}

// æµ‹è¯•å„ç§è¿½åŠ æ‰“å°æœºã€‚è¯¦ç»†çš„æµ‹è¯•åœ¨ä¸Šé¢å·²ç»å……åˆ†è¿›è¡Œï¼›
// è¿™é‡Œæˆ‘ä»¬ä¸»è¦ç¡®ä¿å­—èŠ‚åˆ‡ç‰‡èƒ½æ­£ç¡®æ›´æ–°ã€‚
// md5:00bb4b00e53a3982

const (
	appendResult = "hello world, 23"
	hello        = "hello "
)

func TestAppendf(t *testing.T) {
	b := make([]byte, 100)
	b = b[:copy(b, hello)]
	got := Appendf(b, "world, %d", 23)
	if string(got) != appendResult {
		t.Fatalf("Appendf returns %q not %q", got, appendResult)
	}
	if &b[0] != &got[0] {
		t.Fatalf("Appendf allocated a new slice")
	}
}

func TestAppend(t *testing.T) {
	b := make([]byte, 100)
	b = b[:copy(b, hello)]
	got := Append(b, "world", ", ", 23)
	if string(got) != appendResult {
		t.Fatalf("Append returns %q not %q", got, appendResult)
	}
	if &b[0] != &got[0] {
		t.Fatalf("Append allocated a new slice")
	}
}

func TestAppendln(t *testing.T) {
	b := make([]byte, 100)
	b = b[:copy(b, hello)]
	got := Appendln(b, "world,", 23)
	if string(got) != appendResult+"\n" {
		t.Fatalf("Appendln returns %q not %q", got, appendResult+"\n")
	}
	if &b[0] != &got[0] {
		t.Fatalf("Appendln allocated a new slice")
	}
}
